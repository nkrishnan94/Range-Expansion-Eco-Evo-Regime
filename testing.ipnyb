{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "from stepping_stone_funcs import*\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7.24 s, sys: 41.7 ms, total: 7.29 s\n",
      "Wall time: 7.29 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=20000\n",
    "K=100\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0.001\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_nv = stepping_stone_nonvec(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,L_init)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([[  2,   0,   2, ...,   0,  -2,  98],\n",
       "        [  1,   0,   0, ...,   0,   0,  98],\n",
       "        [  0,   0,   0, ...,   0,  -5, 105],\n",
       "        ...,\n",
       "        [100,   0,   0, ...,   0,   0,   0],\n",
       "        [100,   0,   0, ...,   0,   0,   0],\n",
       "        [100,   0,   0, ...,   0,   0,   0]]),\n",
       " array([0.        , 0.16082198, 0.16235836, 0.17739445, 0.1786832 ,\n",
       "        0.19265761, 0.19632954, 0.41658913, 0.50402263]),\n",
       " 374)"
      ]
     },
     "execution_count": 5,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_nv"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([[  3,   1,  92,   0,   0,   4],\n",
       "        [  1,   0,  93,   0,   0,   6],\n",
       "        [  2,   2,  92,   0,   0,   4],\n",
       "        ...,\n",
       "        [100,   0,   0,   0,   0,   0],\n",
       "        [100,   0,   0,   0,   0,   0],\n",
       "        [100,   0,   0,   0,   0,   0]]),\n",
       " array([0.        , 0.1       , 0.10965369, 0.12077708, 0.12188682,\n",
       "        0.19452851]),\n",
       " 3691634,\n",
       " 0)"
      ]
     },
     "execution_count": 4,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#%%time\n",
    "n_gen=50000\n",
    "K=100\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=.001\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "fix_time_spatial(K, ## population size\n",
    "                     r,\n",
    "                     alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                     mu,\n",
    "                     L_init,\n",
    "                     .0001)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([[  1,   0,   0, ...,   0,   0,   0],\n",
       "        [  2,   0,   0, ...,   0,   0,   0],\n",
       "        [  3,   0,   0, ...,   0,   0,   0],\n",
       "        ...,\n",
       "        [200,   0,   0, ...,   0,   0,   0],\n",
       "        [200,   0,   0, ...,   0,   0,   0],\n",
       "        [200,   0,   0, ...,   0,   0,   0]]),\n",
       " array([0.        , 0.1       , 0.10897091, 0.10914897, 0.10935874,\n",
       "        0.10939189, 0.10941489, 0.10960659, 0.10992274, 0.11002502,\n",
       "        0.11013718, 0.11043559, 0.11049147, 0.11067805, 0.11071709,\n",
       "        0.11088267, 0.11114067, 0.11119268, 0.11159191, 0.11208459,\n",
       "        0.11295893, 0.14557204, 0.19571019, 0.21468587, 0.4585885 ,\n",
       "        0.55828935, 0.67297614, 0.89376384, 1.08310879, 1.3117288 ,\n",
       "        1.44101149, 1.4427984 , 1.58563056, 1.58753643, 1.74570349,\n",
       "        1.74763284, 1.91775612, 1.91810091, 1.91855901, 1.91952282,\n",
       "        1.92005492, 2.10939219, 2.11019615, 2.11088281, 2.31970841,\n",
       "        2.32303369, 2.55422351, 3.74116985, 4.52579594, 4.98002367]),\n",
       " 2234425,\n",
       " 0)"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "#%%time\n",
    "n_gen=50000\n",
    "K=200\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=.001\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "fix_time_spatial(K, ## population size\n",
    "                     r,\n",
    "                     alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                     mu,\n",
    "                     L_init,\n",
    "                     .0001)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 2min 36s, sys: 2.53 s, total: 2min 38s\n",
      "Wall time: 2min 59s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=50000\n",
    "K=500\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=.001\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "fix_time_spatial(K, ## population size\n",
    "                     r,\n",
    "                     alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                     mu,\n",
    "                     L_init,\n",
    "                     .0001)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "from sim_funcs_vectorize_n import*"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 7.08 s, sys: 36.5 ms, total: 7.12 s\n",
      "Wall time: 7.14 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=10000\n",
    "K=100\n",
    "r=.1\n",
    "alpha=1.4\n",
    "mu=0.001\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_v = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,\n",
    "                    L_init,prune,K)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([[  5,  95],\n",
       "        [  1,  99],\n",
       "        [  2,  98],\n",
       "        [  2,  98],\n",
       "        [  3,  97],\n",
       "        [  1,  99],\n",
       "        [  0, 100],\n",
       "        [  0, 100],\n",
       "        [  1,  99],\n",
       "        [  1,  99],\n",
       "        [  1,  99],\n",
       "        [  0, 100],\n",
       "        [  8,  92],\n",
       "        [  4,  96],\n",
       "        [  3,  97],\n",
       "        [  0, 100],\n",
       "        [  4,  96],\n",
       "        [  8,  92],\n",
       "        [  9,  91],\n",
       "        [ 10,  90],\n",
       "        [ 12,  88],\n",
       "        [ 23,  77],\n",
       "        [ 23,  77],\n",
       "        [ 21,  79],\n",
       "        [ 30,  70],\n",
       "        [ 26,  74],\n",
       "        [ 24,  76],\n",
       "        [ 23,  77],\n",
       "        [ 30,  70],\n",
       "        [ 37,  63],\n",
       "        [ 49,  51],\n",
       "        [ 59,  41],\n",
       "        [ 60,  40],\n",
       "        [ 68,  32],\n",
       "        [ 67,  33],\n",
       "        [ 72,  28],\n",
       "        [ 85,  15],\n",
       "        [ 87,  13],\n",
       "        [ 86,  14],\n",
       "        [ 91,   9],\n",
       "        [ 94,   6],\n",
       "        [ 94,   6],\n",
       "        [ 99,   1],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [ 97,   3],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [ 98,   2],\n",
       "        [100,   0],\n",
       "        [ 97,   3],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [ 99,   1],\n",
       "        [ 99,   1],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0],\n",
       "        [100,   0]]), array([0. , 0.1]), 0, 61)"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_v\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "n_gen=50000\n",
    "K=100\n",
    "r=.1\n",
    "alpha=1.2\n",
    "mu=.002\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "fix_time_spatial(K, ## population size\n",
    "                 r,\n",
    "                 alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                 mu,\n",
    "                 L_init,\n",
    "                 .05,\n",
    "                 K,\n",
    "                 True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "n_gen=50000\n",
    "K=100\n",
    "r=.1\n",
    "alpha=1.2\n",
    "mu=.002\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "fix_time_spatial(K, ## population size\n",
    "                 r,\n",
    "                 alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                 mu,\n",
    "                 L_init,\n",
    "                 .05,\n",
    "                 K,\n",
    "                 True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_gen=50000\n",
    "K=1000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_gen=5000\n",
    "K=500\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "K_space = np.array([100,200,500,800,1000])\n",
    "Vs=np.zeros(len(K_space),dtype=np.float64)\n",
    "for i,K in enumerate([100,200,500,800,1000]):\n",
    "    L_init=initialize(K,1,.01)[0]\n",
    "    L_nv = stepping_stone_nonvec(n_gen,## nunmber of gnerations\n",
    "                        K, ## population size\n",
    "                        r,\n",
    "                        alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                        mu,\n",
    "                        L_init)\n",
    "    Vs[i] = L_nv[-1]/(n_gen/200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "73"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.where(L_nv[0][:,0]==K)[0][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "34246.57534246575"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(5000*500)/np.where(L_nv[0][:,0]==K)[0][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 50.4 s, sys: 484 ms, total: 50.9 s\n",
      "Wall time: 54.9 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=50000\n",
    "K=5000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_nv = stepping_stone_nonvec(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,L_init)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4min 23s, sys: 2.22 s, total: 4min 26s\n",
      "Wall time: 4min 42s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=100000\n",
    "K=1000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_nv = stepping_stone_nonvec(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,L_init)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.375590782173245"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(L_nv[-1]*r**.5)/((n_gen/np.where(L_nv[0][:,0]==K)[0][0])*r)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.60839"
      ]
     },
     "execution_count": 36,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_gen=100000\n",
    "K=1000\n",
    "L_nv[-1]/((n_gen/np.where(L_nv[0][:,0]==K)[0][0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 41,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "83"
      ]
     },
     "execution_count": 41,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.where(L_nv[0][:,0]==K)[0][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 4min 34s, sys: 2.5 s, total: 4min 36s\n",
      "Wall time: 4min 47s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=100000\n",
    "K=1000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_v = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,\n",
    "                    L_init,prune,K)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.2145"
      ]
     },
     "execution_count": 38,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_gen=100000\n",
    "K=1000\n",
    "L_v[-1]/((n_gen/np.where(L_v[0][:,0]==K)[0][0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "87"
      ]
     },
     "execution_count": 32,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.where(L_nv[0][:,0]==K)[0][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "35"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_v[-1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 1min 19s, sys: 621 ms, total: 1min 20s\n",
      "Wall time: 1min 22s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "n_gen=100000\n",
    "K=2000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "L_init=initialize(K,1,.01)[0]\n",
    "prune=True\n",
    "L_v = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,\n",
    "                    L_init,prune,False)\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.26"
      ]
     },
     "execution_count": 34,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "n_gen=100000\n",
    "K=2000\n",
    "L_v[-1]/((n_gen/K))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "80.64516129032258"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    " (K/np.where(L_v[0][:,0]==K)[0][0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "80.64516129032258"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(K/np.where(L_v[0][:,0]==K)[0][0])"
   ]
  },
  {
   "cell_type": "raw",
   "metadata": {},
   "source": [
    "L_v = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                K, ## population size\n",
    "                r,\n",
    "                alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                mu,\n",
    "                L_init,prune)\n",
    "\n",
    "Vs[i] = L_v[-1]/(n_gen/200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_gen=5000\n",
    "r=.1\n",
    "alpha=1.1\n",
    "mu=0\n",
    "prune=True\n",
    "K_space = np.array([100,200,500,800,1000])\n",
    "Vs_v=np.zeros(len(K_space),dtype=np.float64)\n",
    "for i,K in enumerate([100,200,500,800,1000]):\n",
    "    L_init=initialize(K,1,.01)[0]\n",
    "    L_v = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                    K, ## population size\n",
    "                    r,\n",
    "                    alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                    mu,\n",
    "                    L_init,prune)\n",
    "    \n",
    "    Vs_v[i] = L_v[-1]/(n_gen/200)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.6 , 0.96, 0.8 , 0.96, 0.84])"
      ]
     },
     "execution_count": 6,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "Vs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "drive_results=[[],[],[]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [],
   "source": [
    "drive_results[0].append(np.array([np.arange(5),np.arange(5)]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[[array('hello', dtype='<U5'),\n",
       "  array(['hello', 'hello'], dtype='<U5'),\n",
       "  array([[0, 1, 2, 3, 4],\n",
       "         [0, 1, 2, 3, 4]])],\n",
       " [],\n",
       " []]"
      ]
     },
     "execution_count": 17,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "drive_results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "K=1000\n",
    "L=initialize(K,1,.1)[0]\n",
    "L_empty= np.array([K,0])\n",
    "g_rates =np.array([0,1])\n",
    "r=.1\n",
    "alpha=1.025\n",
    "mu=.01\n",
    "g_rates=np.array([0,1])\n",
    "n_allele = len(g_rates) -1\n",
    "\n",
    "P = np.ones((n_allele+1,n_allele+1))\n",
    "P[0,:] = 1 - g_rates\n",
    "\n",
    "alleles=np.arange(len(g_rates))\n",
    "rands = np.random.random((3,np.int(K)))\n",
    "n_demes = np.where(L[:,0]!=K)[0][-1] +2\n",
    "deme_seeds = np.random.randint(0,n_demes,(3,np.int(K)))\n",
    "neighbs = np.append(np.expand_dims(deme_seeds[0,:],0),\n",
    "       np.expand_dims((((rands[0,:]<.5) & (deme_seeds[0,:]) !=0) | (deme_seeds[0,:] == (n_demes -1)) *1) *-2+1 +deme_seeds[0,:],0),axis=0).T\n",
    "\n",
    "neighb_counts = np.bincount(neighbs.flatten(),\n",
    "                            #np.max(neighbs)\n",
    "                           )\n",
    "mig_picks = np.zeros((np.int(K),2),dtype=np.int64)\n",
    "cnt = 0\n",
    "for i in np.unique(neighbs.flatten()):\n",
    "    to_ind = np.random.choice(np.repeat(alleles,L[i]),neighb_counts[i],replace=False)\n",
    "    #to_ind = np.repeat(alleles,L[i])[np.searchsorted(np.arange(0,1,1/(K-1)), rands[2,cnt (cnt+neighb_counts[i])],side=\"right\")]\n",
    "    inds = np.where(neighbs==i)\n",
    "    #mig_picks[np.where(neighbs==i)[0],:].take(np.where(neighbs==i)[1]+np.arange(0,len(np.where(neighbs==i)[1])*2,2)) = np.random.choice(np.repeat(alleles,L[i]),neighb_counts[i],replace=False)\n",
    "    for ind in range(len(inds[0])):\n",
    "        mig_picks[inds[0][ind],inds[1][ind]] = to_ind[ind] \n",
    "    cnt+=1    \n",
    "\n",
    "for i in np.unique(neighbs.flatten()):\n",
    "    #L[i] \n",
    "    #L[i]+= neighbs[np.where(neighbs==i)[0],:].take(np.where(neighbs==i)[1]+np.arange(0,len(np.where(neighbs==i)[1])*2,2))\n",
    "    inds = np.where(neighbs==i)\n",
    "    L[i] -= true_bincount( mig_picks[inds[0],:].take(inds[1]+np.arange(0,len(inds[1])*2,2)),\n",
    "                                                      n_allele+1)\n",
    "    L[i] += true_bincount( mig_picks[inds[0],:].take((inds[1]==0)*1+np.arange(0,len(inds[1])*2,2)),\n",
    "                          n_allele+1) \n",
    "dup_counts = np.bincount(deme_seeds[1,:],\n",
    "                           #np.max(deme_seeds[1,:])\n",
    "                          )\n",
    "dup_picks = np.zeros((np.int(K),2),dtype=np.int64)\n",
    "\n",
    "for i in np.unique(deme_seeds[1,:].flatten()):\n",
    "    dup_picks[np.where(deme_seeds[1,:]==i)] = np.random.choice(np.repeat(alleles,L[i]),(dup_counts[i],2),replace=False)\n",
    "\n",
    "for i in np.unique(deme_seeds[1,:]):\n",
    "    dup_inds = np.where(deme_seeds[1,:]==i)\n",
    "    pairs =  dup_picks[np.where(deme_seeds[1,:]==i)].T\n",
    "    dup_bool =(P[:,pairs[1]].T.take(pairs[0])>rands[0].take(dup_inds[0]))\n",
    "    L[i] +=true_bincount(pairs[:,dup_bool].take(np.arange(len(pairs[:,dup_bool][0]))),n_allele+1) -  true_bincount(pairs[:,dup_bool].take(len(pairs[:,dup_bool][0])+np.arange(len(pairs[:,dup_bool][0]))) ,n_allele+1)\n",
    "\n",
    "mut_counts = np.bincount(deme_seeds[2,:], \n",
    "                           #np.max(deme_seeds[2,:])\n",
    "                          )\n",
    "mut_picks = np.zeros(np.int(K),dtype=np.int64)\n",
    "\n",
    "for i in np.unique(deme_seeds[2,:].flatten()):\n",
    "    mut_picks[np.where(deme_seeds[2,:]==i)] =np.random.choice(np.repeat(alleles,L[i]),(mut_counts[i]),replace=False)\n",
    "\n",
    "\n",
    "mt_cnt = 0\n",
    "for i in np.unique(deme_seeds[2,:]):\n",
    "\n",
    "\n",
    "    to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "    mut_bool =(to_mut != 0 ) & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))\n",
    "\n",
    "    ##remove original cell and add mutated cell to cell counts\n",
    "    s_new = np.random.normal(r*alpha,.001,np.sum(mut_bool))\n",
    "    if s_new.size > 0:\n",
    "        for s in s_new:\n",
    "\n",
    "            g_rates = np.sort(np.append(g_rates,np.asarray(s)))\n",
    "            s_pos = np.where(g_rates==s)[0][0]\n",
    "            #print(s_pos)\n",
    "            L = np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "            #L = np.concatenate((L[:,:(s_pos)].T,np.expand_dims(np.zeros(len(L)).astype(int),0),L[:,(s_pos):].T)).T \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "            P = np.ones((len(g_rates),len(g_rates)))\n",
    "\n",
    "            P[0,:] = 1 - g_rates\n",
    "            #alleles = np.arange(n_allele+1)\n",
    "            L_empty = np.array([K]+[0]*(len(g_rates)-1))\n",
    "            L[i,1] -=1\n",
    "            L[i,s_pos] +=1\n",
    "            mt_cnt+=1\n",
    "#shift = 0\n",
    "#while L[0,0]<int(.02*K):\n",
    "#    L=L[1:,:]\n",
    "#    shift+=1\n",
    "\n",
    "#for i in range(shift):\n",
    "#    L=np.append(L,np.expand_dims(L_empty,0),axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "metadata": {},
   "outputs": [],
   "source": [
    "i=0\n",
    "to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "mut_bool =(to_mut != 0 )  & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([False, False, False, False, False, False, False, False, False,\n",
       "       False, False, False, False, False,  True, False, False, False,\n",
       "       False, False,  True, False, False, False, False, False])"
      ]
     },
     "execution_count": 63,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "mut_bool"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.60544895, 0.66961093, 0.52943052, 0.38847457, 0.31327104,\n",
       "       0.94974238, 0.56676759, 0.82921048, 0.11469205, 0.86228571,\n",
       "       0.06864071, 0.3182204 , 0.95942735, 0.71251093, 0.28516477,\n",
       "       0.89900799, 0.10996097, 0.4332883 , 0.78969785, 0.86884449,\n",
       "       0.82504408, 0.34828363, 0.08203012, 0.32501495, 0.14303812,\n",
       "       0.82001156, 0.75634955, 0.76950791])"
      ]
     },
     "execution_count": 47,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "i=2\n",
    "rands[1,:].take(np.where(deme_seeds[2,:]==i)[0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([False, False, False, False, False, False, False, False, False,\n",
       "       False, False, False, False, False, False, False, False, False,\n",
       "       False, False, False, False, False, False])"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 64,
   "metadata": {},
   "outputs": [],
   "source": [
    "i=0\n",
    "to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "mut_bool =(to_mut != 0 )  & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))\n",
    "\n",
    "\n",
    "##remove original cell and add mutated cell to cell counts\n",
    "if np.sum(mut_bool)>1:\n",
    "\n",
    "    for s_0 in to_mut[mut_bool]:\n",
    "        s= np.random.normal(r*alpha**(s_0),.0001)\n",
    "        g_rates = np.sort(np.append(g_rates,np.asarray(s)))\n",
    "        s_pos = np.where(g_rates==s)[0][0]\n",
    "        #print(s_pos)\n",
    "        L = np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "        #L = np.concatenate((L[:,:(s_pos)].T,np.expand_dims(np.zeros(len(L)).astype(int),0),L[:,(s_pos):].T)).T \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "        P = np.ones((len(g_rates),len(g_rates)))\n",
    "\n",
    "        P[0,:] = 1 - g_rates\n",
    "        #alleles = np.arange(n_allele+1)\n",
    "        L_empty = np.array([K]+[0]*(len(g_rates)-1))\n",
    "        L[i,1] -=1\n",
    "        L[i,s_pos] +=1\n",
    "        mt_cnt+=1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "9"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "s_pos"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.025"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "alpha**1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "###computation\n",
    "import numpy as np\n",
    "from numpy import gradient as grad\n",
    "from scipy.integrate import odeint\n",
    "from scipy.interpolate import interp1d\n",
    "import glob\n",
    "import os\n",
    "\n",
    "\n",
    "#visualization\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "import matplotlib as mpl\n",
    "from matplotlib.colors import ListedColormap, LinearSegmentedColormap\n",
    "from matplotlib import rcParams\n",
    "from matplotlib.lines import Line2D\n",
    "\n",
    "from matplotlib.patches import Circle\n",
    "from matplotlib.patches import Rectangle\n",
    "from itertools import product\n",
    "\n",
    "\n",
    "import pandas as pd\n",
    "import seaborn as sns\n",
    "\n",
    "#custom fu\n",
    "from sim_funcs_vectorize_n import*\n",
    "\n",
    "\n",
    "from scipy.optimize import curve_fit\n",
    "##for improved readability of markdown\n",
    "#import warnings f\n",
    "#warnings.filterwarnings('ignore')\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "##takes a long time to run!\n",
    "\n",
    "n_gen = 10000\n",
    "K = 5000\n",
    "r = .1\n",
    "alpha = 1.1\n",
    "mu = 0\n",
    "Ltips = []\n",
    "for n in range(10):\n",
    "    for K in [100, 200,500, 1000,2000,5000,10000]:\n",
    "        out = run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                        K, ## population size\n",
    "                        r,\n",
    "                        alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                        mu,\n",
    "                        initialize(K,1,mu)[0],True)\n",
    "\n",
    "        Ltips.append(np.where(out[0][:,1]>0)[0][-1])\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [],
   "source": [
    "L"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "L_arr=np.copy(Ltips)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([43, 60, 52, 62, 50, 65, 64, 27, 45, 42, 47, 84, 70, 71, 54, 39, 59,\n",
       "       69, 59, 70, 62, 71, 33, 40, 67, 49, 75, 72, 39, 66, 51, 47, 53, 66,\n",
       "       78, 51, 40, 63, 57, 61, 66, 62, 36, 53, 46, 66, 76, 66, 82, 41, 39,\n",
       "       64, 61, 64, 60, 81, 31, 47, 52, 46, 85, 66, 65, 31, 35, 55, 52, 61,\n",
       "       79, 84])"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_arr"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([42.4, 45.7, 52.4, 57.4, 64.2, 68.3, 72.1])"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x1a22e20518>]"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot([100, 200,500, 1000,2000,5000,10000],np.mean(L_arr.reshape((10,7)),axis=0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x1a23eedbe0>]"
      ]
     },
     "execution_count": 50,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 42,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[10000, 10000],\n",
       "       [10002,  9998],\n",
       "       [10003,  9997],\n",
       "       ...,\n",
       "       [20000,     0],\n",
       "       [20000,     0],\n",
       "       [20000,     0]])"
      ]
     },
     "execution_count": 42,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(initialize(K,1,.01))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([10000,  9998,  9997,  9996,  9995,  9994,  9992,  9990,  9987,\n",
       "        9984,  9980,  9974,  9967,  9958,  9947,  9932,  9914,  9890,\n",
       "        9859,  9821,  9772,  9709,  9631,  9531,  9406,  9250,  9055,\n",
       "        8815,  8522,  8167,  7745,  7250,  6683,  6049,  5360,  4637,\n",
       "        3905,  3195,  2536,  1950,  1454,  1052,   739,   506,   339,\n",
       "         222,   142,    90,    56,    34,    21,    12,     7,     4,\n",
       "           2,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0,     0,     0,     0,\n",
       "           0,     0,     0,     0,     0,     0])"
      ]
     },
     "execution_count": 49,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "initialize(K,1,.01)[0][:,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [],
   "source": [
    "K=100\n",
    "s=.1\n",
    "U=.001"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {},
   "outputs": [
    {
     "ename": "SyntaxError",
     "evalue": "invalid syntax (<ipython-input-19-cf80966ac4e2>, line 1)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;36m  File \u001b[0;32m\"<ipython-input-19-cf80966ac4e2>\"\u001b[0;36m, line \u001b[0;32m1\u001b[0m\n\u001b[0;31m    vs = 2*(.1* (1+s))**.5 - 2*\u001b[0m\n\u001b[0m                                ^\u001b[0m\n\u001b[0;31mSyntaxError\u001b[0m\u001b[0;31m:\u001b[0m invalid syntax\n"
     ]
    }
   ],
   "source": [
    "vs = 2*(.1* (1+s))**.5 - 2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x1a1dba0390>,\n",
       " <matplotlib.lines.Line2D at 0x1a1dba0da0>]"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(out[0][-1][:50])\n",
    "plt.plot(initialize(K,1,mu)[0][:50])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.49458023, 0.48468862, 0.47974282, 0.47479702, 0.46985121,\n",
       "       0.46490541, 0.45501381, 0.45006801, 0.4352306 , 0.42039319,\n",
       "       0.40555579, 0.38577258, 0.36104357, 0.33631455, 0.30169394,\n",
       "       0.27201912, 0.23739851, 0.19783209, 0.16321147, 0.12859086,\n",
       "       0.09891605, 0.07418703, 0.05440382, 0.03956642, 0.02472901,\n",
       "       0.01483741, 0.0098916 , 0.        , 0.        , 0.        ,\n",
       "       0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "       0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "       0.        , 0.        , 0.        , 0.        , 0.        ,\n",
       "       0.        , 0.        , 0.        , 0.        , 0.        ])"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(initialize(K,1,mu)[0][:50][:,1])*initialize(K,1,mu)[0][:50][:,1]*U*s**.5 / K"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([  0,   2,   3,   4,   5,   6,   8,   9,  12,  15,  18,  22,  27,\n",
       "        32,  39,  45,  52,  60,  67,  74,  80,  85,  89,  92,  95,  97,\n",
       "        98, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100,\n",
       "       100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100])"
      ]
     },
     "execution_count": 37,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "initialize(K,1,mu)[0][:50][:,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 153,
   "metadata": {},
   "outputs": [],
   "source": [
    "##standing wave solution of Fisher wave\n",
    "def standing_wave(y0,x,D,rw):\n",
    "    w = y0[0]      ##initial value for wave profile at x =0, i.e. w(x=0)\n",
    "    z = y0[1]      ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. dw/dx(x=0)\n",
    "    dwdx = z\n",
    "    dzdx =(-2*((rw*D)**.5)*dwdx -w*rw*(1-w))/D\n",
    "    \n",
    "    return [dwdx,dzdx]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 154,
   "metadata": {},
   "outputs": [],
   "source": [
    "def surf_prob(y0,x,rw,rm,D,bfunc):\n",
    "    u = y0[0]  ##initial value for probability at x =0, i.e. u(x=0)\n",
    "    z = y0[1]  ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. du/dx(x=0)\n",
    "    dudx = z\n",
    "    dzdx =(-(2*((D*rw)**.5))*dudx+ u*(rm)*(1-bfunc(x))-u**2)/D\n",
    "    return [dudx,dzdx]\n",
    "\n",
    "\n",
    "def surf_prob_solve(x, b,rw,rm,D, u0,du0 ):\n",
    "    ##generate a continuous function from initial standing wave\n",
    "    bfunc = interp1d(x,b, bounds_error=False, fill_value=\"extrapolate\")\n",
    "    \n",
    "    ##find range of positions to integrate over\n",
    "    #x = np.linspace(0,len(b)-1,len(b))\n",
    "    ##integarate\n",
    "    s =odeint(surf_prob,[u0,du0],x,args = (rw,rm,D,bfunc))\n",
    "    return s"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 298,
   "metadata": {},
   "outputs": [],
   "source": [
    "##generate data\n",
    "K=100\n",
    "D=1\n",
    "\n",
    "s=.1\n",
    "\n",
    "x_init=500\n",
    "dx =1\n",
    "x = np.linspace(0,int(x_init-dx),int(x_init/dx))\n",
    "r = .1\n",
    "dx =1\n",
    "x = np.linspace(0,int(x_init-dx),int(x_init/dx))\n",
    "b0= 1 \n",
    "db0 = -1/K\n",
    "stand = odeint(standing_wave,[b0,db0],np.arange(500),args=(1,.1))[:,0]\n",
    "L_f = np.where(stand*K<1)[0][0]\n",
    "rm=.11\n",
    "L = (2*3.141 )/( 2*((D*(rm))**.5) * (2*(rm/r -1))**.5)\n",
    "u0 = rm*np.exp(-L)\n",
    "dudx = rm*((D*(rm))**.5)*np.exp(-L)\n",
    "p_surf = surf_prob_solve(np.arange(500)[:L_f],stand[0:L_f],r,rm,D,u0, dudx)\n",
    "fix_count = p_surf[:,0][:L_f]*stand[:L_f]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 333,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x151870e588>]"
      ]
     },
     "execution_count": 333,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "U=.001\n",
    "K = 100\n",
    "plt.plot(stand[:L_f]*K*U*np.log(s*stand[:L_f]*K))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 304,
   "metadata": {},
   "outputs": [],
   "source": [
    "Ne = K*stand[:L_f]\n",
    "U=.001"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 321,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.30357142857142855"
      ]
     },
     "execution_count": 321,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(Ne*U* np.log(Ne*.1)>.2)/len(Ne)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 318,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "56"
      ]
     },
     "execution_count": 318,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "len(Ne)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#from sim_funcs_1 import*\n",
    "from numba import jit,njit\n",
    "import numpy as np\n",
    "from numpy.random import choice\n",
    "from numba import prange\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.integrate import odeint \n",
    "from numba import jit,njit\n",
    "##standing wave solution of Fisher wave\n",
    "\n",
    "\n",
    "def standing_wave(y0,x,D,rw):\n",
    "    w = y0[0]      ##initial value for wave profile at x =0, i.e. w(x=0)\n",
    "    z = y0[1]      ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. dw/dx(x=0)\n",
    "    dwdx = z\n",
    "    dzdx =(-2*((rw*D)**.5)*dwdx -w*rw*(1-w))/D ## fisher equation in comoving frame\n",
    "    \n",
    "    return [dwdx,dzdx]\n",
    "def initialize(K,n_allele,mu):\n",
    "    ## generate standing wave\n",
    "    stand = odeint(standing_wave,[1,-(2*2**.5)/K],np.arange(70),args=(2*2**.5,1))[:,0]\n",
    "    \n",
    "    ## cuttoff non integer cell density based off of carry capacity K\n",
    "    w_0 = (K*stand).astype(int)\n",
    "    w_0 = w_0[w_0>1]\n",
    "    \n",
    "    ## subtract wild type cells from carrying capacity to get 'emopty' particle count\n",
    "    L = np.vstack(((K-w_0),w_0)).T\n",
    "    L = np.append(L,np.zeros((len(w_0),n_allele-1)),axis=1)\n",
    "\n",
    "    ##array strucutre of an empty deme to be added on as needed \n",
    "    L_empty= np.append([K],np.zeros(n_allele,dtype=int))\n",
    "\n",
    "    ## add on some number of empty demes\n",
    "    for i in range(500):\n",
    "        L= np.append(L,[L_empty],axis=0)\n",
    "        \n",
    "    return L.astype(int), L_empty\n",
    "\n",
    "\n",
    "@njit\n",
    "def true_bincount(arr,minlength):\n",
    "    binned = np.bincount(arr)\n",
    "    return np.append(binned,np.zeros(minlength - len(binned),dtype=np.int64))\n",
    "\n",
    "\n",
    "\n",
    "@njit\n",
    "def advindexer(arr,index, to_index):\n",
    "    arr[index] = to_index\n",
    "    return arr\n",
    "    \n",
    "\n",
    "\n",
    "@njit\n",
    "def update(L, ## population\n",
    "    L_empty, ## empty deme structure\n",
    "    P, ## porbability matrix for mutation\n",
    "    K, # population size\n",
    "    g_rates,\n",
    "    r,\n",
    "    alpha,\n",
    "    mu): ##mutation rate\n",
    "        #L_tip = np.where(L[:,0]!=K)[0][-1]\n",
    "    n_allele = len(g_rates) -1\n",
    "\n",
    "    alleles=np.arange(len(g_rates))\n",
    "    rands = np.random.random((3,np.int(K)))\n",
    "    n_demes = np.where(L[:,0]!=K)[0][-1] +2\n",
    "    deme_seeds = np.random.randint(0,n_demes,(3,np.int(K)))\n",
    "    neighbs = np.append(np.expand_dims(deme_seeds[0,:],0),\n",
    "           np.expand_dims((((rands[0,:]<.5) & (deme_seeds[0,:]) !=0) | (deme_seeds[0,:] == (n_demes -1)) *1) *-2+1 +deme_seeds[0,:],0),axis=0).T\n",
    "\n",
    "    neighb_counts = np.bincount(neighbs.flatten(),\n",
    "                                #np.max(neighbs)\n",
    "                               )\n",
    "    mig_picks = np.zeros((np.int(K),2),dtype=np.int64)\n",
    "    cnt = 0\n",
    "    for i in np.unique(neighbs.flatten()):\n",
    "        to_ind = np.random.choice(np.repeat(alleles,L[i]),neighb_counts[i],replace=False)\n",
    "        #to_ind = np.repeat(alleles,L[i])[np.searchsorted(np.arange(0,1,1/(K-1)), rands[2,cnt (cnt+neighb_counts[i])],side=\"right\")]\n",
    "        inds = np.where(neighbs==i)\n",
    "        #mig_picks[np.where(neighbs==i)[0],:].take(np.where(neighbs==i)[1]+np.arange(0,len(np.where(neighbs==i)[1])*2,2)) = np.random.choice(np.repeat(alleles,L[i]),neighb_counts[i],replace=False)\n",
    "        for ind in range(len(inds[0])):\n",
    "            mig_picks[inds[0][ind],inds[1][ind]] = to_ind[ind] \n",
    "        cnt+=1    \n",
    "\n",
    "    for i in np.unique(neighbs.flatten()):\n",
    "        #L[i] \n",
    "        #L[i]+= neighbs[np.where(neighbs==i)[0],:].take(np.where(neighbs==i)[1]+np.arange(0,len(np.where(neighbs==i)[1])*2,2))\n",
    "        inds = np.where(neighbs==i)\n",
    "        L[i] -= true_bincount( mig_picks[inds[0],:].take(inds[1]+np.arange(0,len(inds[1])*2,2)),\n",
    "                                                          n_allele+1)\n",
    "        L[i] += true_bincount( mig_picks[inds[0],:].take((inds[1]==0)*1+np.arange(0,len(inds[1])*2,2)),\n",
    "                              n_allele+1) \n",
    "    dup_counts = np.bincount(deme_seeds[1,:],\n",
    "                               #np.max(deme_seeds[1,:])\n",
    "                              )\n",
    "    dup_picks = np.zeros((np.int(K),2),dtype=np.int64)\n",
    "\n",
    "    for i in np.unique(deme_seeds[1,:].flatten()):\n",
    "        dup_picks[np.where(deme_seeds[1,:]==i)] = np.random.choice(np.repeat(alleles,L[i]),(dup_counts[i],2),replace=False)\n",
    "\n",
    "    for i in np.unique(deme_seeds[1,:]):\n",
    "        dup_inds = np.where(deme_seeds[1,:]==i)\n",
    "        pairs =  dup_picks[np.where(deme_seeds[1,:]==i)].T\n",
    "        dup_bool =(P[:,pairs[1]].T.take(pairs[0])>rands[0].take(dup_inds[0]))\n",
    "        L[i] +=true_bincount(pairs[:,dup_bool].take(np.arange(len(pairs[:,dup_bool][0]))),n_allele+1) -  true_bincount(pairs[:,dup_bool].take(len(pairs[:,dup_bool][0])+np.arange(len(pairs[:,dup_bool][0]))) ,n_allele+1)\n",
    "   \n",
    "    mut_counts = np.bincount(deme_seeds[2,:], \n",
    "                               #np.max(deme_seeds[2,:])\n",
    "                              )\n",
    "    mut_picks = np.zeros(np.int(K),dtype=np.int64)\n",
    "\n",
    "    for i in np.unique(deme_seeds[2,:].flatten()):\n",
    "        mut_picks[np.where(deme_seeds[2,:]==i)] =np.random.choice(np.repeat(alleles,L[i]),(mut_counts[i]),replace=False)\n",
    "\n",
    "\n",
    "    mt_cnt = 0\n",
    "    for i in np.unique(deme_seeds[2,:]):\n",
    "\n",
    "\n",
    "        to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "        mut_bool =(to_mut != 0 ) &(g_rates[to_mut] ==r ) & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))\n",
    "\n",
    "\n",
    "        ##remove original cell and add mutated cell to cell counts\n",
    "        s_new = np.random.normal(r*alpha,.001,np.sum(mut_bool))\n",
    "        if s_new.size > 0:\n",
    "            for s in s_new:\n",
    "\n",
    "                g_rates = np.sort(np.append(g_rates,np.asarray(s)))\n",
    "                s_pos = np.where(g_rates==s)[0][0]\n",
    "                #print(s_pos)\n",
    "                L = np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "                #L = np.concatenate((L[:,:(s_pos)].T,np.expand_dims(np.zeros(len(L)).astype(int),0),L[:,(s_pos):].T)).T \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "                P = np.ones((len(g_rates),len(g_rates)))\n",
    "\n",
    "                P[0,:] = 1 - g_rates\n",
    "                #alleles = np.arange(n_allele+1)\n",
    "                L_empty = np.array([K]+[0]*(len(g_rates)-1))\n",
    "                L[i,1] -=1\n",
    "                L[i,s_pos] +=1\n",
    "                mt_cnt+=1\n",
    "    #shift = 0\n",
    "    #while L[0,0]<int(.02*K):\n",
    "    #    L=L[1:,:]\n",
    "    #    shift+=1\n",
    "\n",
    "    #for i in range(shift):\n",
    "    #    L=np.append(L,np.expand_dims(L_empty,0),axis=0)\n",
    "    return L, L_empty, g_rates, P,mt_cnt\n",
    "\n",
    "@njit\n",
    "def run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                K, ## population size\n",
    "                r,\n",
    "                alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                mu,\n",
    "                L_init,prune):\n",
    "    \n",
    "\n",
    "\n",
    "    ##initialize probability matrix\n",
    "    L_empty = L_init[-1]\n",
    "    L = np.copy(L_init)\n",
    "    g_rates = np.array([0,r])\n",
    "    n_allele = len(g_rates)-1\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,:] = 1 - g_rates\n",
    "    ## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "\n",
    "    #if track:\n",
    "    #L_history = []\n",
    "    #    L_history = [L]\n",
    "    mut_events=0\n",
    "    scount = 0\n",
    "    for t in range(n_gen):\n",
    "        L, L_empty, g_rates, P,new_muts =update(L,L_empty,P,K,g_rates,r,alpha,mu)\n",
    "        mut_events += new_muts\n",
    "        \n",
    "        if prune:\n",
    "            non_empty = np.sum(L,axis=0)!=0\n",
    "            L= L[:,non_empty]\n",
    "            L_empty = L_empty[non_empty]\n",
    "            g_rates = g_rates[non_empty]\n",
    "\n",
    "        \n",
    "        while L[0,0]<1:\n",
    "            L=L[1:,:]\n",
    "            L=np.append(L,np.expand_dims(L_empty,0),axis=0) \n",
    "            scount+=1\n",
    "\n",
    "         \n",
    "\n",
    "    #    if track:\n",
    "     #   L_history.append(L)\n",
    "        \n",
    "    #if track:\n",
    "    #    return L_history, g_rates\n",
    "    #else:\n",
    "    return  L, g_rates,scount\n",
    "\n",
    "@njit\n",
    "def fix_time_spatial(K, ## population size\n",
    "                     r,\n",
    "                     alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                     mu,\n",
    "                     L_init,\n",
    "                     thresh,\n",
    "                     prune):  ## mutation rate\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    L_empty = L_init[-1]\n",
    "    L = L_init\n",
    "    g_rates = np.array([0,r])\n",
    "    n_allele = len(g_rates)-1\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,:] = 1 - g_rates\n",
    "    \n",
    "    fixed=False\n",
    "    muts_check = False\n",
    "    del_check =False\n",
    "    del_fix = False\n",
    "    arise_time =0 \n",
    "    fixed=False\n",
    "    mut_events = 0\n",
    "    t = 0\n",
    "    \n",
    "    while not fixed:\n",
    "        L, L_empty, g_rates, P,new_muts =update(L,L_empty,P,K,g_rates,r,alpha,mu)\n",
    "        mut_events += new_muts\n",
    "        \n",
    "        if prune:\n",
    "            non_empty = np.sum(L,axis=0)!=0\n",
    "            L = L[:,non_empty]\n",
    "            L_empty = L_empty[non_empty]\n",
    "            g_rates = g_rates[non_empty]\n",
    "        \n",
    "\n",
    "        while L[0,0]<1:\n",
    "            L=L[1:,:]\n",
    "            L=np.append(L,np.expand_dims(L_empty,0),axis=0)\n",
    "            \n",
    "        if len(g_rates)>2 ==True and not muts_check:\n",
    "            ## record time\n",
    "            arise_time = t\n",
    "            muts_check = True\n",
    "        if not len(g_rates)>2:\n",
    "            muts_check = False\n",
    "            arise_time = 0\n",
    "\n",
    "        ## check if fixed\n",
    "        n_demes = np.where(L[:,0]!=K)[0][-1] +2\n",
    "        wt_ind = np.where(g_rates==r)[0][0]\n",
    "        #fix_bools = L[:(n_demes-2),wt_ind] < np.asarray(thresh*np.sum(L[:(n_demes-2),1:],axis=1),dtype=np.dtype('int64'))\n",
    "        fixed = np.all((L[L[:,0]!=K,wt_ind])/(K-L[L[:,0]!=K,0]) < thresh)\n",
    "        #fixed = np.all(fix_bools)\n",
    "        #fixed = np.sum(L[:,1:n_allele])<(thresh*init_pop)\n",
    "\n",
    "        t+=1\n",
    "\n",
    "\n",
    "    return L, g_rates,t,arise_time, mut_events"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 136,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 5000\n",
    "n_gen=10000\n",
    "r=.1\n",
    "alpha=0\n",
    "mu=0\n",
    "L_init = initialize(K,1,mu)[0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 137,
   "metadata": {},
   "outputs": [],
   "source": [
    "L_empty = L_init[-1]\n",
    "L = np.copy(L_init)\n",
    "g_rates = np.array([0,r])\n",
    "n_allele = len(g_rates)-1\n",
    "P = np.ones((n_allele+1,n_allele+1))\n",
    "P[0,:] = 1 - g_rates\n",
    "## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "\n",
    "#if track:\n",
    "#L_history = []\n",
    "#    L_history = [L]\n",
    "mut_events=0\n",
    "scount = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 138,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(n_gen):\n",
    "    L, L_empty, g_rates, P,new_muts =update(L,L_empty,P,K,g_rates,r,alpha,mu)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 141,
   "metadata": {},
   "outputs": [],
   "source": [
    "dist = np.where(L[:,0]==K)[0][0] - np.where(L_init[:,0]==K)[0][0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 143,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.0037"
      ]
     },
     "execution_count": 143,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dist/(n_gen)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 144,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 10000\n",
    "n_gen=4000\n",
    "r=.1\n",
    "alpha=0\n",
    "mu=0\n",
    "L_init = initialize(K,1,mu)[0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 145,
   "metadata": {},
   "outputs": [],
   "source": [
    "L_empty = L_init[-1]\n",
    "L = np.copy(L_init)\n",
    "g_rates = np.array([0,r])\n",
    "n_allele = len(g_rates)-1\n",
    "P = np.ones((n_allele+1,n_allele+1))\n",
    "P[0,:] = 1 - g_rates\n",
    "## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "\n",
    "#if track:\n",
    "#L_history = []\n",
    "#    L_history = [L]\n",
    "mut_events=0\n",
    "scount = 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [],
   "source": [
    "for i in range(n_gen):\n",
    "    L, L_empty, g_rates, P,new_muts =update(L,L_empty,P,K,g_rates,r,alpha,mu)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 147,
   "metadata": {},
   "outputs": [],
   "source": [
    "dist = np.where(L[:,0]==K)[0][0] - np.where(L_init[:,0]==K)[0][0]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 148,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "18"
      ]
     },
     "execution_count": 148,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "dist"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 151,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.6324555320336759"
      ]
     },
     "execution_count": 151,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(2*.1**.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "5.692099788303083"
      ]
     },
     "execution_count": 155,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(60-51)* .1**.5 *2"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 146,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.1"
      ]
     },
     "execution_count": 146,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "r"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 97,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "10.0"
      ]
     },
     "execution_count": 97,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "100/10"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 98,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "1.4699488491048593"
      ]
     },
     "execution_count": 98,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "2299/1564"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "100.0"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "1000*.1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 101,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 10.9 s, sys: 10 s, total: 21 s\n",
      "Wall time: 21.9 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "K= 5000\n",
    "\n",
    "r=.1\n",
    "alpha=5\n",
    "mu=.01\n",
    "n_gen =100\n",
    "thresh=3/K\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L,g=run_stepping_stone(n_gen,K,r,alpha,mu,L_init,True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 102,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 27.2 s, sys: 30.8 s, total: 58 s\n",
      "Wall time: 1min 6s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "K= 5000\n",
    "\n",
    "r=.1\n",
    "alpha=5\n",
    "mu=.01\n",
    "n_gen =100\n",
    "thresh=3/K\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L,g=run_stepping_stone(n_gen,K,r,alpha,mu,L_init,False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([0, 1, 2]),)"
      ]
     },
     "execution_count": 33,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "non_extinct"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 50.2 s, sys: 1.05 s, total: 51.3 s\n",
      "Wall time: 1min 4s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "K= 100\n",
    "\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.0001\n",
    "n_gen =10000\n",
    "thresh=3/K\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L, g_rates,t,arise_time, mut_events=fix_time_spatial(K,r,alpha,mu,L_init,.2,True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "True"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.all((L[L[:,0]!=K,1])/(K-L[L[:,0]!=K,0]) < .2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([12,  7,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n",
       "        0,  0])"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L[L[:,0]!=K,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 98,  97,  97, 100,  89,  90,  94,  80,  73,  70,  58,  42,  45,\n",
       "        34,  20,  15,   9,  12,   4])"
      ]
     },
     "execution_count": 8,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(K-L[L[:,0]!=K,0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 100\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.1\n",
    "n_gen =100\n",
    "n_allele =1\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "\n",
    "##initialize probability matrix\n",
    "#L = L_init\n",
    "L_empty = np.array([K]+[0]*n_allele)\n",
    "L=L_init\n",
    "P = np.ones((n_allele+1,n_allele+1))\n",
    "P[0,1:] = [r*alpha]\n",
    "\n",
    "L_empty = L_init[-1]\n",
    "L = L_init\n",
    "g_rates = np.array([0,r])\n",
    "n_allele = len(g_rates)-1\n",
    "P = np.ones((n_allele+1,n_allele+1))\n",
    "P[0,:] = 1 - g_rates\n",
    "## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "alleles = np.arange(n_allele+1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/Users/nikhilkrishnan/anaconda3/lib/python3.7/site-packages/ipykernel_launcher.py:1: RuntimeWarning: divide by zero encountered in true_divide\n",
      "  \"\"\"Entry point for launching an IPython kernel.\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x152a910b70>]"
      ]
     },
     "execution_count": 21,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(1/np.arange(90)**2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [],
   "source": [
    "for dt in range(100):\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n",
      "1\n"
     ]
    }
   ],
   "source": [
    "mu = .8\n",
    "g_rates = np.array([0,.1])\n",
    "for i in np.unique(deme_seeds[2,:]):\n",
    "    to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "    mut_bool =(to_mut != 0 ) &(g_rates[to_mut] ==r ) & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))\n",
    "    if np.sum(mut_bool) > 0:\n",
    "        print(1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ True,  True,  True,  True,  True,  True])"
      ]
     },
     "execution_count": 28,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([0,.1])[to_mut] ==r"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([False, False, False, False, False, False])"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "i= 8\n",
    "to_mut = mut_picks[np.where(deme_seeds[2,:]==i)]\n",
    "(to_mut != 0 )\n",
    "to_mut != n_allele "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([], dtype=float64)"
      ]
     },
     "execution_count": 30,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.random.normal(r*alpha,.001,len(mut_bool))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([False, False, False, False, False, False])"
      ]
     },
     "execution_count": 25,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(to_mut != 0 ) &(to_mut != n_allele ) & (mu>rands[1,:].take(np.where(deme_seeds[2,:]==i)[0]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from numpy.random import choice\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.integrate import odeint \n",
    "from numba import jit,njit\n",
    "##standing wave solution of Fisher wave\n",
    "\n",
    "\n",
    "def standing_wave(y0,x,D,rw):\n",
    "    w = y0[0]      ##initial value for wave profile at x =0, i.e. w(x=0)\n",
    "    z = y0[1]      ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. dw/dx(x=0)\n",
    "    dwdx = z\n",
    "    dzdx =(-2*((rw*D)**.5)*dwdx -w*rw*(1-w))/D ## fisher equation in comoving frame\n",
    "    \n",
    "    return [dwdx,dzdx]\n",
    "\n",
    "\n",
    "def initialize(K,n_allele,mu):\n",
    "    ## generate standing wave\n",
    "    stand = odeint(standing_wave,[1,-(2*2**.5)/K],np.arange(70),args=(2*2**.5,1))[:,0]\n",
    "    \n",
    "    ## cuttoff non integer cell density based off of carry capacity K\n",
    "    w_0 = (K*stand).astype(int)\n",
    "    w_0 = w_0[w_0>1]\n",
    "    \n",
    "    ## subtract wild type cells from carrying capacity to get 'emopty' particle count\n",
    "    L = np.vstack(((K-w_0),w_0)).T\n",
    "    L = np.append(L,np.zeros((len(w_0),n_allele-1)),axis=1)\n",
    "\n",
    "    ##array strucutre of an empty deme to be added on as needed \n",
    "    L_empty= np.append([K],np.zeros(n_allele,dtype=int))\n",
    "\n",
    "    ## add on some number of empty demes\n",
    "    for i in range(500):\n",
    "        L= np.append(L,[L_empty],axis=0)\n",
    "        \n",
    "    return L.astype(int), L_empty\n",
    "\n",
    "\n",
    "\n",
    "## given  ab array with counts and an array withprobabilities return index from first array\n",
    "# faster than np.random.choice for smallish arrays\n",
    "@njit\n",
    "def choice(options,probs):\n",
    "    x = np.random.rand()\n",
    "    cum = 0\n",
    "    for i,p in enumerate(probs):\n",
    "        cum += p\n",
    "        ##sum of probability must be 1\n",
    "        if x < cum:\n",
    "            break\n",
    "    return options[i]\n",
    "\n",
    "\n",
    "@njit\n",
    "def run_stepping_stone(n_gen,## nunmber of gnerations\n",
    "                K, ## population size\n",
    "                r,\n",
    "                alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                mu,\n",
    "                L_init,\n",
    "                L_history):  ## mutation rate\n",
    "    \n",
    "\n",
    "    ##initialize probability matrix\n",
    "    #L = L_init\n",
    "    L_empty = L_init[-1]\n",
    "    L=L_init\n",
    "    g_rates = np.array([0,r])\n",
    "    n_allele = len(g_rates)-1\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,:] = 1 - g_rates\n",
    "    \n",
    "    ## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "    alleles = np.arange(n_allele+1)\n",
    "    \n",
    "    #slots for picked alleles each iteration to be stored, so array doesnt havent to be regerated each time\n",
    "    picks = np.array([0,0,0,0])\n",
    "    \n",
    "    #sstore trace history\n",
    "    #L_history= np.expand_dims(L,0)\n",
    "\n",
    "    #for i in range(n_gen-1):\n",
    "    #    L_history = np.concatenate((L_history, np.expand_dims(np.zeros(L.shape),0)))\n",
    "\n",
    "   \n",
    "    for t in range(n_gen):\n",
    "        for dt in range(K):\n",
    "            \n",
    "            #number of demes with a non empty particle (+2)\n",
    "            n_demes = np.where(L[:,0]!=K)[0][-1] +2\n",
    "\n",
    "            #pick adjacent demes tobe swapped, pick demes for duplication and mutation\n",
    "            ind_1 = np.random.randint(0, n_demes)\n",
    "            if (np.random.random() < .5 and ind_1 != 0) or ind_1 == n_demes - 1:\n",
    "                ind_2 = ind_1 - 1\n",
    "            else:\n",
    "                ind_2 = ind_1 + 1\n",
    "            neighb = np.array([ind_1, ind_2])\n",
    "            dup_deme, mut_deme = np.random.randint(0,n_demes,2)\n",
    "\n",
    "\n",
    "            #dmigration: pick two cells from each of the selected demes, and swap them\n",
    "            for i in range(2):\n",
    "                picks[i] = choice(alleles, L[neighb][i]/K)\n",
    "                \n",
    "            for inds in [[0,1],[1,0]]:\n",
    "                L[neighb[inds[0]],picks[inds[0]]] -= 1\n",
    "                L[neighb[inds[0]],picks[inds[1]]] += 1\n",
    "\n",
    "\n",
    "            #duplication: pick two cells from the selected deme and echange first with copy of second according to\n",
    "            #3 probability matrix\n",
    "            for i in range(2,4):\n",
    "                picks[i] = choice(alleles,L[dup_deme]/K)\n",
    "\n",
    "            if P[picks[2],picks[3]] > np.random.random():\n",
    "                L[dup_deme,picks[2]] += 1\n",
    "                L[dup_deme,picks[3]] -= 1\n",
    "\n",
    "\n",
    "\n",
    "            ##mutation\n",
    "            mut_deme = np.random.randint(n_demes)\n",
    "            #picks[4] = choice(alleles,L[mut_deme]/K)\n",
    "            #picks.append(choice(alleles,L[mut_deme]/K))\n",
    "            if mu>np.random.random():\n",
    "                #3 only particles that are not empty spaces and are not the 'peak' in the landscape strucutre can mutate\n",
    "                #if picks[4] != n_allele and picks[4] != 0:\n",
    "                    ## mutate cell and fromat in terms of cell counts i.e. [empty cell count,...,chosen cell count]\n",
    "\n",
    "                ##remove original cell and add mutated cell to cell counts\n",
    "                s_new = np.random.normal(r*alpha,.001)\n",
    "                g_rates = np.sort(np.append(g_rates,np.asarray(s_new)))\n",
    "                s_pos = np.where(g_rates==s_new)[0][0]\n",
    "                #print(s_pos)\n",
    "                L = np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "                #L = np.concatenate((L[:,:(s_pos)].T,np.expand_dims(np.zeros(len(L)).astype(int),0),L[:,(s_pos):].T)).T \n",
    "                \n",
    "\n",
    "                n_allele = len(g_rates)-1\n",
    "\n",
    "                P = np.ones((n_allele+1,n_allele+1))\n",
    "                \n",
    "                P[0,:] = 1 - g_rates\n",
    "                alleles = np.arange(n_allele+1)\n",
    "                L_empty = np.array([K]+[0]*n_allele)\n",
    "                L[mut_deme,1] -=1\n",
    "                L[mut_deme,s_pos] +=1\n",
    "\n",
    "            ##track how many demes are to be omitted\n",
    "            shift = 0\n",
    "            while L[0,0]<int(.02*K):\n",
    "                L=L[1:,:]\n",
    "                shift+=1\n",
    "            #if L[0,0]<int(.02*K):\n",
    "            #    shift = np.where(L[:,0]<int(.02*K))[-1][0]\n",
    "            #    L = L[shift:,:]\n",
    "            for i in range(shift):\n",
    "                L=np.append(L,np.expand_dims(L_empty,0),axis=0)\n",
    "\n",
    "\n",
    "        #L_history = np.concatenate((L_history, np.expand_dims(L,0)),axis=0)\n",
    "        #L_history[t] = L\n",
    "    return L,g_rates\n",
    "\n",
    "\n",
    "@njit\n",
    "def fix_time_spatial(K, ## population size\n",
    "                     r,\n",
    "                     alpha,## fitness landscape (Growthrates of each genotype (should be <<1))\n",
    "                     mu,\n",
    "                     L_init,\n",
    "                     thresh):  ## mutation rate\n",
    "    \n",
    "\n",
    "    ##initialize probability matrix\n",
    "    #L = L_init\n",
    "    L_empty = L_init[-1]\n",
    "    L=L_init\n",
    "    g_rates = np.array([0,r])\n",
    "    n_allele = len(g_rates)-1\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,:] = 1 - g_rates\n",
    "    \n",
    "    ## list of allele number - pre-established so array doesnt have to be regenerated\n",
    "    alleles = np.arange(n_allele+1)\n",
    "    \n",
    "    #slots for picked alleles each iteration to be stored, so array doesnt havent to be regerated each time\n",
    "    picks = np.array([0,0,0,0])\n",
    "    \n",
    "    #sstore trace history\n",
    "    #L_history= np.expand_dims(L,0)\n",
    "\n",
    "    #for i in range(n_gen-1):\n",
    "    #    L_history = np.concatenate((L_history, np.expand_dims(np.zeros(L.shape),0)))\n",
    "\n",
    "    fixed=False\n",
    "    muts_check = False\n",
    "    del_check =False\n",
    "    del_fix = False\n",
    "    arise_time =0 \n",
    "    t = 0\n",
    "\n",
    "    while not fixed:\n",
    "        \n",
    "        #number of demes with a non empty particle (+2)\n",
    "        n_demes = np.where(L[:,0]!=K)[0][-1] +2\n",
    "\n",
    "        #pick adjacent demes tobe swapped, pick demes for duplication and mutation\n",
    "        ind_1 = np.random.randint(0, n_demes)\n",
    "        if (np.random.random() < .5 and ind_1 != 0) or ind_1 == n_demes - 1:\n",
    "            ind_2 = ind_1 - 1\n",
    "        else:\n",
    "            ind_2 = ind_1 + 1\n",
    "        neighb = np.array([ind_1, ind_2])\n",
    "        dup_deme, mut_deme = np.random.randint(0,n_demes,2)\n",
    "\n",
    "\n",
    "        #dmigration: pick two cells from each of the selected demes, and swap them\n",
    "        for i in range(2):\n",
    "            picks[i] = choice(alleles, L[neighb][i]/K)\n",
    "\n",
    "        for inds in [[0,1],[1,0]]:\n",
    "            L[neighb[inds[0]],picks[inds[0]]] -= 1\n",
    "            L[neighb[inds[0]],picks[inds[1]]] += 1\n",
    "\n",
    "\n",
    "        #duplication: pick two cells from the selected deme and echange first with copy of second according to\n",
    "        #3 probability matrix\n",
    "        for i in range(2,4):\n",
    "            picks[i] = choice(alleles,L[dup_deme]/K)\n",
    "\n",
    "        if P[picks[2],picks[3]] > np.random.random():\n",
    "            L[dup_deme,picks[2]] += 1\n",
    "            L[dup_deme,picks[3]] -= 1\n",
    "\n",
    "\n",
    "\n",
    "        ##mutation\n",
    "        mut_deme = np.random.randint(n_demes)\n",
    "        #picks[4] = choice(alleles,L[mut_deme]/K)\n",
    "        #picks.append(choice(alleles,L[mut_deme]/K))\n",
    "        if mu>np.random.random() and L[mut_deme,1]>0:\n",
    "            #3 only particles that are not empty spaces and are not the 'peak' in the landscape strucutre can mutate\n",
    "            #if picks[4] != n_allele and picks[4] != 0:\n",
    "                ## mutate cell and fromat in terms of cell counts i.e. [empty cell count,...,chosen cell count]\n",
    "\n",
    "            ##remove original cell and add mutated cell to cell counts\n",
    "            s_new = np.random.normal(r*alpha,.001)\n",
    "            g_rates = np.sort(np.append(g_rates,np.asarray(s_new)))\n",
    "            s_pos = np.where(g_rates==s_new)[0][0]\n",
    "            #print(s_pos)\n",
    "            L = np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "            #L = np.concatenate((L[:,:(s_pos)].T,np.expand_dims(np.zeros(len(L)).astype(int),0),L[:,(s_pos):].T)).T \n",
    "\n",
    "\n",
    "            n_allele = len(g_rates)-1\n",
    "\n",
    "            P = np.ones((n_allele+1,n_allele+1))\n",
    "\n",
    "            P[0,:] = 1 - g_rates\n",
    "            alleles = np.arange(n_allele+1)\n",
    "            L_empty = np.array([K]+[0]*n_allele)\n",
    "            L[mut_deme,1] -=1\n",
    "            L[mut_deme,s_pos] +=1\n",
    "\n",
    "        ##track how many demes are to be omitted\n",
    "        shift = 0\n",
    "        while L[0,0]<int(.02*K):\n",
    "            L=L[1:,:]\n",
    "            shift+=1\n",
    "        #if L[0,0]<int(.02*K):\n",
    "        #    shift = np.where(L[:,0]<int(.02*K))[-1][0]\n",
    "        #    L = L[shift:,:]\n",
    "        for i in range(shift):\n",
    "            L=np.append(L,np.expand_dims(L_empty,0),axis=0)\n",
    "\n",
    "        ## check if fixed\n",
    "        wt_ind = np.where(g_rates==r)[0][0]\n",
    "        fix_bools = L[:(n_demes-2),wt_ind] < np.asarray(thresh*np.sum(L[:(n_demes-2),1:],axis=1),dtype=np.dtype('int64'))\n",
    "        fixed = np.all(fix_bools)\n",
    "        t+=1\n",
    "        #L_history = np.concatenate((L_history, np.expand_dims(L,0)),axis=0)\n",
    "        #L_history[t] = L\n",
    "    return L,g_rates\n",
    "\n",
    "\n",
    "## run simulation until a fixation event occurs (fixation to some threshold 'thresh')\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "#Run the automaton\n",
    "#Implements cell division. The division rates are based on the experimental data\n",
    "\n",
    "\n",
    "    \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "fixed = L[:,wt_ind] < np.asarray(thresh*np.sum(L[:,1:],axis=1),dtype=np.dtype('int64'))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 100\n",
    "\n",
    "r=.1\n",
    "alpha=5\n",
    "mu=.0001\n",
    "n_gen =10000\n",
    "thresh=3/K\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L,g=run_stepping_stone(n_gen,K,r,alpha,mu,L_init,np.zeros((n_gen,len(L_init),2)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "CPU times: user 6.24 s, sys: 1.08 s, total: 7.32 s\n",
      "Wall time: 7.46 s\n"
     ]
    }
   ],
   "source": [
    "%%time\n",
    "K= 100\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.01\n",
    "n_gen =100\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L,g=fix_time_spatial(K,r,alpha,mu,L_init,.5)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "%%time\n",
    "K= 5000\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.0001\n",
    "n_gen =100\n",
    "L_init = initialize(K,1,mu)[0]\n",
    "L,g=fix_time_spatial(K,r,alpha,mu,L_init,.05)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[  6,   0,   0, ...,   0,   0,   0],\n",
       "       [  4,   0,   0, ...,   0,   0,   0],\n",
       "       [  9,   0,   0, ...,   0,   0,   0],\n",
       "       ...,\n",
       "       [100,   0,   0, ...,   0,   0,   0],\n",
       "       [100,   0,   0, ...,   0,   0,   0],\n",
       "       [100,   0,   0, ...,   0,   0,   0]])"
      ]
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n",
       "       1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n",
       "       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])"
      ]
     },
     "execution_count": 94,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(L[:,1:]>0,axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [],
   "source": [
    "K=100\n",
    "mu=.01\n",
    "L_init = initialize(K,5,mu)[0]\n",
    "L_init.shape\n",
    "\n",
    "@njit\n",
    "def check(L,s_pos):\n",
    "    #return np.vstack((np.zeros(5)))\n",
    "    return np.array([s_pos]+[0]*s_pos)\n",
    "\n",
    "    #return np.concatenate((L[:,:(s_pos)].T, np.expand_dims(np.zeros(len(L),dtype=np.dtype( np.int64)),0), L[:,(s_pos):].T)).T\n",
    "    #return np.vstack(np.expand_dims(np.zeros(len(L)),0))\n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([3, 0, 0, 0])"
      ]
     },
     "execution_count": 18,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "check(L_init,3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([  0, 100,   0,   0,   0,   0])"
      ]
     },
     "execution_count": 12,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L_init[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "##standing wave solution of Fisher wave\n",
    "def standing_wave(y0,x,D,rw):\n",
    "    w = y0[0]      ##initial value for wave profile at x =0, i.e. w(x=0)\n",
    "    z = y0[1]      ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. dw/dx(x=0)\n",
    "    dwdx = z\n",
    "    dzdx =(-2*((rw*D)**.5)*dwdx -w*rw*(1-w))/D\n",
    "    \n",
    "    return [dwdx,dzdx]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([200, 198, 197, 196, 195, 194, 192, 190, 188, 185, 181, 176, 170,\n",
       "       163, 155, 145, 134, 122, 108,  93,  79,  65,  51,  39,  29,  21,\n",
       "        15,  10,   7,   4,   2,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0])"
      ]
     },
     "execution_count": 24,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.sum(L_init[:,1:],axis=1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 578,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fit_dist(r,alpha,dist_key):\n",
    "    dist_dict = {'exponential':np.random.exponential,\n",
    "                 'gamma':np.random.gamma,\n",
    "                 'normal':np.random.normal}\n",
    "    func = dist_dict[dist_key]\n",
    "    s_bar  = r*func(alpha)\n",
    "    return s_bar\n",
    "\n",
    "##standing wave solution of Fisher wave\n",
    "def standing_wave(y0,x,D,rw):\n",
    "    w = y0[0]      ##initial value for wave profile at x =0, i.e. w(x=0)\n",
    "    z = y0[1]      ##initial value for rate of change of profile w.r.t. position x , at x=0 i.e. dw/dx(x=0)\n",
    "    dwdx = z\n",
    "    dzdx =(-2*((rw*D)**.5)*dwdx -w*rw*(1-w))/D\n",
    "    \n",
    "    return [dwdx,dzdx]\n",
    "\n",
    "\n",
    "###given a list of demes (indexes), pick two neighobiring ones at random\n",
    "def rand_neighbors(demes):\n",
    "    ind_1 = np.random.choice(demes)\n",
    "    left = demes[:ind_1][-1:]\n",
    "    right = demes[ind_1:][1:2]\n",
    "    neighb = np.append(left,right).flatten()\n",
    "    ind_2=choice(neighb)\n",
    "    neigh = [ind_1,ind_2]\n",
    "    neigh.sort()\n",
    "    return np.array(neigh)\n",
    "\n",
    "## covert a list of cell counts for each particle type to an array of \n",
    "#all particles represented with their type represented by an itenged\n",
    "def counts_to_cells(counts,n_allele):\n",
    "    cells = np.unique(cells,return_counts=True)\n",
    "    return cells\n",
    "\n",
    "## covert an array of all cells and their type to a list of counts for each cell type \n",
    "def cells_to_counts(cell_types,g_rates):\n",
    "    g_r = np.unique(cell_types,return_counts=True)[0]\n",
    "    raw_counts = np.unique(cell_types,return_counts=True)[1]\n",
    "    cell_counts = []\n",
    "    for i in g_rates:\n",
    "        if any(g_r == i):\n",
    "            cell_counts.append(raw_counts[np.where(g_r == i)[0][0]])\n",
    "        else:\n",
    "            cell_counts.append(0)\n",
    "    cell_counts = np.array(cell_counts)\n",
    "\n",
    "    return cell_counts\n",
    "    \n",
    "    \n",
    "## from a list 2d array of the cell list from two neighboring demes\n",
    "##pick two cells to be swapped at random and return resulting cell list\n",
    "def migration(cell_counts,g_rates,K,r):\n",
    "    picks = []\n",
    "    cell_types = [] \n",
    "    for i in [0,1]:\n",
    "        pick_ind=choice(np.arange(K))\n",
    "        picks.append(np.arange(K) == pick_ind)\n",
    "        cell_types.append(np.repeat( g_rates, cell_counts[i].astype(int)))\n",
    "    picks = np.array(picks)\n",
    "    keep =  ~np.array(picks)\n",
    "    \n",
    "\n",
    "\n",
    "    cell_types[0]= np.append(cell_types[0][keep[0]], [cell_types[1][picks[1]]])\n",
    "    cell_types[1]= np.append(cell_types[1][keep[1]], [cell_types[0][picks[0]]])\n",
    "    return np.array(cell_types)\n",
    "\n",
    "## from the cell list from the chosen d0eme\n",
    "##pick *-\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n",
    "#wo cells and replace one with a duplicate of the other according\n",
    "##to transition matrix\n",
    "def duplication(cell_counts,g_rates,K,r):\n",
    "    pick_ind=choice(np.arange(K),2,replace= False)\n",
    "    cell_types = np.repeat(g_rates, cell_counts.astype(int))\n",
    "    picks = np.array([np.arange(K) == pick_ind[i] for i in [0,1]])\n",
    "    r= np.random.random()\n",
    "    P=prob_mat(g_rates)\n",
    "    #print(cell_types)\n",
    "    if P[tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])]> r:\n",
    "        cell_types[pick_ind[1]] =cell_types[pick_ind[0]]\n",
    "    return cell_types\n",
    "    \n",
    " ## from the cell list from the chosen deme\n",
    "##pick a cell and mutate it with probability according to mutation rate\n",
    "def mutation(mu,alpha,dist_key, cell_counts,g_rates,K,r):\n",
    "\n",
    "    cell_types = np.repeat(g_rates,cell_counts.astype(int))\n",
    "    pick_ind=choice(np.arange(K))\n",
    "    p= np.random.random()\n",
    "    s_pos=0\n",
    "    if mu>p:\n",
    "        if cell_types[pick_ind] == r :\n",
    "            s_new = fit_dist(r,alpha,dist_key)\n",
    "            cell_types[pick_ind] = s_new\n",
    "            g_rates = np.sort(np.append(g_rates,[cell_types[pick_ind]]))\n",
    "            s_pos = np.where(g_rates==s_new)[0][0]\n",
    "    return cell_types, g_rates,s_pos\n",
    "\n",
    "## perform stepping stone alogrithm (migration, duplication, mutation) for each step\n",
    "## and return new simulation box, recenter\n",
    "\n",
    "def recenter(L, g_rates, K):\n",
    "    shift = 0\n",
    "    L_empty= np.append([K],np.zeros(len(g_rates)-1,dtype=float))\n",
    "    while L[0,0]<int(.02*K):\n",
    "        L=L[1:,:]\n",
    "        shift+=1\n",
    "    for i in range(shift):\n",
    "        L=np.append(L,[L_empty],axis=0)\n",
    "    return L\n",
    "\n",
    "\n",
    "def update(L,g_rates,dist_key,K,r,alpha,mu):\n",
    "    #demes = np.arange(len(L))\n",
    "    L_tip = np.where(L[:,0]!=K)[0][-1]\n",
    "    demes = np.arange(L_tip+2)\n",
    "    #migration\n",
    "    neighbors = rand_neighbors(demes)\n",
    "    cells = migration(L[neighbors],g_rates,K,r)\n",
    "    counts = [cells_to_counts(cell,g_rates) for cell in cells]\n",
    "    L[neighbors] = np.array(counts)\n",
    "\n",
    "    #duplication\n",
    "    dup_deme = choice(demes)\n",
    "    cells = duplication(L[dup_deme],g_rates,K,r)\n",
    "    counts = cells_to_counts(cells,g_rates)\n",
    "    L[dup_deme] = counts\n",
    "\n",
    "    ##mutation\n",
    "    mut_deme = choice(demes)\n",
    "    cells, g_rates,s_pos = mutation(mu,alpha,dist_key, L[mut_deme],g_rates,K,r)\n",
    "    counts = cells_to_counts(cells,g_rates)\n",
    "    for i in range(len(g_rates)-len(L[0])):\n",
    "        L = np.append(np.append(L[:,:(s_pos)],\n",
    "                                np.vstack(np.zeros(len(L))),axis=1),L[:,(s_pos):],axis=1)\n",
    "        #print(counts)\n",
    "        #print(L[mut_deme])\n",
    "        #print(L)\n",
    "    L[mut_deme]=counts\n",
    "        \n",
    "    return L,g_rates\n",
    "\n",
    "\n",
    "def initialize(K,r,alpha,mu):\n",
    "    stand = odeint(standing_wave,[1,-(2*2**.5)/K],np.arange(70),args=(2*2**.5,1))[:,0]\n",
    "    w_0 = (K*stand).astype(int)\n",
    "    w_0 = w_0[w_0>1]\n",
    "    L = np.vstack(((K-w_0),w_0)).T\n",
    "    g_rates = np.array([0,r])\n",
    "\n",
    "    ##initialize array\n",
    "    L_empty= np.append([K],np.zeros(len(g_rates)-1))\n",
    "\n",
    "    for i in range(70):\n",
    "        L= np.append(L,[L_empty],axis=0)\n",
    "    return L.astype(int), g_rates\n",
    "\n",
    "def prob_mat(g_rates):\n",
    "    P = np.ones((len(g_rates),len(g_rates)))\n",
    "    P[0,:] = 1-g_rates\n",
    "    return P \n",
    "\n",
    "def prune(L,g_rates):\n",
    "    \n",
    "    full_bools = np.where(np.sum(L,axis=0)!=0)[0][-1]\n",
    "    L=L[:,:full_bools]\n",
    "    g_rates = g_rates[:full_bools]\n",
    "    return L,g_rates\n",
    "\n",
    "## run one dimensional stepping stone for a given number of possible beneficil mutations, and generations   \n",
    "def run_stepping_stone(n_gen,K,r,alpha,mu,dist_key = 'exponential'):\n",
    "    func_args = [K,r,alpha,mu]\n",
    "    ##initialize probability matrix\n",
    "    c = 1\n",
    "    move=10\n",
    "    L, g_rates = initialize(*func_args)\n",
    "    L_history=[L]\n",
    "    #begin evolution\n",
    "    count = 0\n",
    "    for t in range(n_gen):\n",
    "        for dt in range(K):\n",
    "            L,g_rates = update(L,g_rates,dist_key,*func_args)\n",
    "            \n",
    "            L= recenter(L,g_rates,K)\n",
    "        \n",
    "        #L,g_rates =prune(L,g_rates)\n",
    "        L_history.append(L)\n",
    "        \n",
    "\n",
    "        count+=1\n",
    "    return L_history, g_rates\n",
    "\n",
    "\n",
    "## run a two allele 1d stepping stone simulation, recording mutant establishment and fixation along simulation box\n",
    "def fix_time(K,r,alpha,mu,thresh,dist_key , track):\n",
    "    func_args = [K,r,alpha,mu]\n",
    "    ##initialize probability matrix\n",
    "    c = 1\n",
    "    move=10\n",
    "    L, g_rates = initialize(*func_args)\n",
    "    L_history=[L]\n",
    "    #begin evolution\n",
    "    count = 0\n",
    "    #begin evolution\n",
    "    fixed=False\n",
    "    t = 0\n",
    "\n",
    "    fix_times = np.zeros(len(L))\n",
    "    est_times = np.zeros(len(L))\n",
    "    fb_1, eb_1 = (np.zeros(len(L)) == 1),(np.zeros(len(L)) == 1) \n",
    "    while not fixed:\n",
    "        L,g_rates = update(L,g_rates,dist_key,*func_args)\n",
    "        L= recenter(L,g_rates,K)\n",
    "        wt_ind = np.where(g_rates==r)[0][0]\n",
    "        fix_bools = L[:,wt_ind] < int(thresh*K)\n",
    "        #est_bools = L[:,2] > int(1/(r*alpha))\n",
    "        fixed= all(fix_bools)\n",
    "\n",
    "        fix_times  = [max(i,time) for i, time in zip((fix_bools^fb_1)*t,fix_times)]\n",
    "            #est_times  = [max(i,time) for i, time in zip((est_bools^eb_1)*t,est_times)]\n",
    "        fb_1= fix_bools\n",
    "        t+=1\n",
    "    return L,fix_times,g_rates\n",
    "\n",
    "      \n",
    "\n",
    "        "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 76,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 200\n",
    "\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.001\n",
    "\n",
    "thresh=3/K\n",
    "\n",
    "L,g=run_stepping_stone(5000,K,r,alpha,mu,dist_key = 'normal')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "K= 200\n",
    "\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.001\n",
    "\n",
    "thresh=3/K\n",
    "\n",
    "L,times=fix_time(K,r,alpha,mu,thresh,dist_key = 'normal')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "trace = L[1500]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 91,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(101, 16)"
      ]
     },
     "execution_count": 91,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L[1500][:,inds].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {},
   "outputs": [],
   "source": [
    "inds = np.where(np.sum(L[1500],axis=0)!=0)[0]\n",
    "trace = L[1500][:,inds]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAtsAAAELCAYAAAAIpkoaAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8li6FKAAAgAElEQVR4nOzdeZxcVZ3//9e5dWvtfUvS2ReyEEJCCEtAxGENiCyOMCiDOjLKOqOCu4gzzjAjMs7Xx/xwGXXcQFRQhAACEhZB9gBhE5IQsq+ddHqt/d46vz+q2WIn6e6qzu3l/Xw8+tFN6t57PtUJXe8+9bnnGGstIiIiIiJSfk7QBYiIiIiIjFQK2yIiIiIig0RhW0RERERkkChsi4iIiIgMEoVtEREREZFBorAtIiIiIjJIFLZFRERERAbJkAzbxphzjTE3GGP+bIzpNMZYY8wvg65LRERERKQ/3KAL2IuvAQuAbmAzMCfYckRERERE+m9IzmwDVwKzgGrgsoBrEREREREZkCE5s22tffjNr40xQZYiIiIiIjJgQ3VmW0RERERk2BuxYbvnpkobdB0iIiIiMnoNyTaSUhhjLgYufscfKXCLiIiIyGDrtfd5xM1sW2t/ZK09Iug6RERERERGXNgWERERERkqFLZFRERERAaJwraIiIiIyCBR2BYRERERGSRDcjUSY8w5wDk9/zmu5/Mxxpif93y9y1r7+QNemIiIiIhIPxhrh97KeMaYfwX+ZR+HbLDWTt3PNSzAUHx+IiIiIjLi9Lr035AM2+WgsC0iIiIiB9DoWGdbRERERGSoUNiWYcVay003vcoRR9zE3Xe/EXQ5IiIiIvs04ttI5s796YDOnzixiu997yQOOqiurHXJwD333HYuuug+3nijg2QyTyLhctpp0/jxj0+lvj4edHkiIiIyuo3Onm34rwGd7ziGaDTEN77xHq66ahGhkN4ECMrOnSmuuuphbrvtddJp712PRSIhEgmX//u/JXzoQ7MCqlBEREREYXtAKipcpk+v5ZZbzuTggxvKUJn0VT7vc8MNz/P1rz9BPu+TyxX2emwi4XLiiZP5yU+WMGZMxQGsUkRERARQ2C7lWhCLuXzlK0fxla8sxnU1yz3YHnhgA//4j3+ktTVFMunt/wQgHHaIx11+8INT+MhH5mBMr//mRURERAaDwnapEgmXSZOqufXWM5k/v6ls15W3rVvXzqWXLuOxx7aQSvUtZO8pkXA59tgJ3Hjj6TQ3V5a5QhEREZFeKWyXSzzuctVVi/j6148lEgmV/foDsX59B62taRYuHIvjHJgZ3XQ6z+OPbyWRcJk5s47GxviAZ5OTyRz/9m9PcsMNK8jlfHy/tH+XrmuIxVz+539O5BOfmKdZbhERERlsCtvllEi4jBtXwa23nsmiReP2f8Igsdby05++zKc//RCOYwiFDKedNo3zzpvNKadMobo6WtbxNmzo4O671/Kb36xk+fLtRKPFXzayWR/HMUyaVMWcOfUcdtgYZs+uZ9asOmbOrKOmpvc6rLX85jcr+ed/fpBUyvurGyBLVVER5vDDx3DzzWcwaVJ1Wa8tIiIi8g4K24MhHne5/PLDuPba44jF3EEda08dHVk+/vF7WbZs/V+1XFRVRchmPQ49tInzz5/NmWfOYPbs+n7P8ObzPk88sZU77ljD73+/mpaWFMaY/YZix4GKigjGQDrtEYu5TJ5cxSGHNLBgwRhmzSoG8C996VFWr24jmcz3+/n3les6RKMh/uu/3selly7QLLeIiIgMBoXtwRKPuzQ1xbnlljNZvHj8oI8H8Mwz2zj77Ntpa8uSzfr7PDYWC+E4hsrKCOeccxB/+7czed/7Ju31l4OdO1Pce+86brllJX/60yZCIYdkMk+hUJ5/K65rSCTCAHR25spyzb6oqAgzb14Dv/rVB5g+vfaAjSsiIiKjgsL2YIvHXS66aB7XX/++t8JkuRUKlm9+82n+4z+eGlDLhTFvznr7LF7czIc/PIf3v386u3alufPONdxyyyrWresgHHbo7h682eagvLl++ic+cQhf//qxjB2rZQJFRESkLBS2D4R43CUWC/G5zx3BZZcdVtadDXfsSPKhDy1lxYqWAa/UsadEwsX3LeGwQzbrk8/vfS3rkSQSCREKGS65ZAFXX300jY2JoEsSERGR4U1h+0CKx12stXz4w3P40peOYs6c0jbE+eMf13H++XeTTObwvJH5dxaEaLQYuv/pnxbyla8cTW1tLOiSREREZHhS2A5CKGQIh0MsWjSWr3/9GE45ZUq/btDL5Xy+8IVH+PGPXyr7Sh3ytlgsRCjkcNVVi/j8548s+youIiIiMuIpbAetsjJMfX2Mr3xlMR/72Nz99nWvXdvOWWfdztq1HQraB0g87hIKGb785aP47GcXUVERCbokERERGR4UtoeKioowxsClly7gs59dxIQJVX91zM03v8ollywjnfbKtgqI9F0i4eK6DtdccwxXXHEY8fjg3PAqIiIiI4bC9lATiYRwHFiyZBpXX300Rx7ZTDKZ45OfvJ8771xTtpsgZeASCZdIJMS//uuxXHrpAqLRA7uWuoiIiAwbCttDlTHF9oUZM2ppa8uya1eKTGbfa2fLgVVRESYWC3HFFQupqBjYLPfhh4/l5JOnlLkyERERGSIUtkVK5TgGxxnYuZFIiM985nCuvfa9OI52sRQRERlhFLZFgpZIuBx77Hhuu+1srXgiIiIysvQatgc4RyciA5FKefz5z1uYN+/nrFq1O+hyREREZJApbIscYNmsz+bNXSxadBN33bUm6HJERERkEClsiwTAWkgm85x//t38y788ruUdRURERiiFbZEApdMe3/72cs444za6unJBlyMiIiJlprAtErBUyuPhhzcxf/7PWbOmLehyREREpIwUtkWGgGzWZ8OGThYuvJF7710bdDkiIiJSJgrbIkOEtdDdnedDH7qTa699kpG6LKeIiMhoorAtMsSk0x7f/ObTnHXW7SST6uMWEREZzhS2RYagVMrjgQc2sGDBjaxb1x50OSIiIjJACtsiQ1Qm47NuXQcLFvyCZcvWB12OiIiIDIDCtsgQVihYurrynH32HVx//TPq4xYRERlmFLZFhoF02uMb33iCc8+9k1QqH3Q5IiIi0kcK2yLDRCrlcc89a1m48EY2bOgIuhwRERHpA4VtkWEkk/FZs6ad+fN/wZ/+tDHockRERGQ/FLZFhplCwdLZmeP97/89/+//Pas+bhERkSFMYVtkmEqnPa655jE+/OG7yWS8oMsRERGRXihsiwxjqZTHXXe9waJFN7F5c1fQ5YiIiMgeFLZFhrl02mPVqt3Mm/dzHntsc9DliIiIyDsMOGwbY1YZYz5njGkoZ0Ei0n++b+noyHLqqb/ju999Xn3cIiIiQ4QZ6IuyMaYAWCAH3A78yFr7p/KVVhpjTM8T+69gCxE5wBIJlw9+cCY/+ckSolE36HJERERGC9PbH5bSRvItYAcQBc4HHjTGrDTGXKXZbpHgpFIev//96xx55C/ZurU76HJERERGtQHPbAMYY0LAmcAlwCkUw/ubs92/B34c1Gy3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\n",
      "text/plain": [
       "<Figure size 864x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "rng=45\n",
    "fig,ax =plt.subplots(figsize=(12,4))\n",
    "\n",
    "\n",
    "\n",
    "colors = ['darkblue','darkred','salmon','darkgrey','blue','teal','red','silver',\n",
    "          'pink','orange','grey','purple','lightblue','magenta','navy']\n",
    "labels = ['Wild-type', 'Single mutant', 'Double mutant']\n",
    "for i in range(len(trace[0])-1):\n",
    "    ax.fill_between(np.arange(rng),np.sum(trace[:rng,1+i:],axis=1),color=colors[i])\n",
    "    \n",
    "    \n",
    "ax.spines['right'].set_visible(False)\n",
    "ax.spines['top'].set_visible(False)\n",
    "\n",
    "ax.spines['left'].set_linewidth(2)\n",
    "ax.spines['bottom'].set_linewidth(2)\n",
    "\n",
    "\n",
    "ax.set_ylim(0,200)\n",
    "ax.set_yticks([200])\n",
    "\n",
    "ax.set_yticklabels([1],fontsize=20)\n",
    "\n",
    "ax.set_ylabel('Frequency',fontsize=25)\n",
    "ax.set_xlabel('Position',fontsize=25)\n",
    "ax.set_xticks([])\n",
    "ax.set_xlim(0,rng)\n",
    "\n",
    "plt.savefig('clonal_interfere.pdf')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([  8., 113.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   2.,   0.,\n",
       "         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         1.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,   0.,   0.,   3.,   3.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,   2.,   0.,   0.,   5.,   2.,   0.,   0.,\n",
       "         2.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,   0.,   0.,   0.,   4.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,   1.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,   0.,   0.,  38.,   0.,   0.,   0.,   0.,   0.,   0.,\n",
       "         0.,   0.,  14.,   0.,   2.])"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L[1500][10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 544,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors = rand_neighbors(demes)\n",
    "cells = migration(L[neighbors],g_rates,K,r)\n",
    "counts = [cells_to_counts(cell,g_rates) for cell in cells]\n",
    "L[neighbors] = np.array(counts)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 607,
   "metadata": {},
   "outputs": [],
   "source": [
    "neighbors = choice(demes)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 650,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.])"
      ]
     },
     "execution_count": 650,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "P=prob_mat(g_rates)\n",
    "#print(cell_types)\n",
    "P[tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 643,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "(array([1]), array([1]))"
      ]
     },
     "execution_count": 643,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 662,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0. , 0.1])"
      ]
     },
     "execution_count": 662,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cell_types = np.repeat(g_rates, cell_counts.astype(int))\n",
    "cell_types[[0,-1]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 663,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.9])"
      ]
     },
     "execution_count": 663,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "P[tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 608,
   "metadata": {},
   "outputs": [],
   "source": [
    "cell_counts = L[neighbors]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 665,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[1. , 0.9],\n",
       "       [1. , 1. ]])"
      ]
     },
     "execution_count": 665,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "P"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 667,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.9"
      ]
     },
     "execution_count": 667,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "P[0,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 659,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1.])"
      ]
     },
     "execution_count": 659,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "P[tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 664,
   "metadata": {},
   "outputs": [],
   "source": [
    "pick_ind = np.array([0,-1])\n",
    "cell_types = np.repeat(g_rates, cell_counts.astype(int))\n",
    "r= np.random.random()\n",
    "P=prob_mat(g_rates)\n",
    "#print(cell_types)\n",
    "if P[tuple([np.where(cell_types[ind] == g_rates)[0] for ind in pick_ind])]> r:\n",
    "    cell_types[pick_ind[1]] =cell_types[pick_ind[0]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 657,
   "metadata": {},
   "outputs": [],
   "source": [
    "cells= cell_types"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 600,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[array([75, 25]), array([99,  1])]"
      ]
     },
     "execution_count": 600,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[cells_to_counts(cell,g_rates) for cell in cells]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 601,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[ 74,  26],\n",
       "       [100,   0]])"
      ]
     },
     "execution_count": 601,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L[[19,20]]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 658,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([10, 90])"
      ]
     },
     "execution_count": 658,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "cells_to_counts(cell_types,g_rates)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 623,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 9, 91])"
      ]
     },
     "execution_count": 623,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "L[neighbors]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 439,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "1it [02:40, 160.24s/it]"
     ]
    },
    {
     "ename": "OSError",
     "evalue": "[Errno 22] Invalid argument",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mOSError\u001b[0m                                   Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-439-32f6cabe4ed4>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     24\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     25\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 26\u001b[0;31m     \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'two_allele_data_%s.npy'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mresults\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mparams_out\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     27\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     28\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'two_allele_data_%s.npy'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mresults\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mparams_out\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/numpy/lib/npyio.py\u001b[0m in \u001b[0;36msave\u001b[0;34m(file, arr, allow_pickle, fix_imports)\u001b[0m\n\u001b[1;32m    519\u001b[0m         \u001b[0marr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masanyarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    520\u001b[0m         format.write_array(fid, arr, allow_pickle=allow_pickle,\n\u001b[0;32m--> 521\u001b[0;31m                            pickle_kwargs=pickle_kwargs)\n\u001b[0m\u001b[1;32m    522\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    523\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mown_fid\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/numpy/lib/format.py\u001b[0m in \u001b[0;36mwrite_array\u001b[0;34m(fp, array, version, allow_pickle, pickle_kwargs)\u001b[0m\n\u001b[1;32m    591\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mpickle_kwargs\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    592\u001b[0m             \u001b[0mpickle_kwargs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 593\u001b[0;31m         \u001b[0mpickle\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mprotocol\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mpickle_kwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    594\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflags\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mf_contiguous\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflags\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mc_contiguous\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    595\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0misfileobj\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfp\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mOSError\u001b[0m: [Errno 22] Invalid argument"
     ]
    }
   ],
   "source": [
    "from stepping_stone_funcs import*\n",
    "from tqdm import tqdm\n",
    "from itertools import product\n",
    "import numpy as np\n",
    "import datetime\n",
    "\n",
    "start = datetime.datetime.now()\n",
    "K_space = np.array([100,500])\n",
    "mu_space = np.array([.0005,.001,.005])\n",
    "alphas = np.array([3,5])\n",
    "\n",
    "reps= 1\n",
    "\n",
    "params_out = ['reps='  +str(reps),'K='+str(K_space),'mu='+str(mu_space),'alphas='+str(alphas) ]\n",
    "\n",
    "r=.1\n",
    "\n",
    "results = []\n",
    "\n",
    "for rep, K,mu,a in tqdm(product(range(reps), K_space,mu_space, alphas)):\n",
    "    L = fix_time(K,2,r,a,mu,3/K)\n",
    "    results.append(np.asarray(L))\n",
    "    \n",
    "    \n",
    "    \n",
    "    np.save('two_allele_data_%s.npy' % start,np.array([results,params_out]))\n",
    "    \n",
    "np.save('two_allele_data_%s.npy' % start,np.array([results,params_out]))\n",
    "\n",
    "    \n",
    "    \n",
    "    \n",
    "            \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    \n",
    "    \n",
    "  \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "            \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 444,
   "metadata": {},
   "outputs": [
    {
     "ename": "OSError",
     "evalue": "[Errno 22] Invalid argument",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mOSError\u001b[0m                                   Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-444-895b7a4cf0e3>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'two_allele_data.npy'\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mresults\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mparams_out\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/numpy/lib/npyio.py\u001b[0m in \u001b[0;36msave\u001b[0;34m(file, arr, allow_pickle, fix_imports)\u001b[0m\n\u001b[1;32m    519\u001b[0m         \u001b[0marr\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masanyarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marr\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    520\u001b[0m         format.write_array(fid, arr, allow_pickle=allow_pickle,\n\u001b[0;32m--> 521\u001b[0;31m                            pickle_kwargs=pickle_kwargs)\n\u001b[0m\u001b[1;32m    522\u001b[0m     \u001b[0;32mfinally\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    523\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mown_fid\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/numpy/lib/format.py\u001b[0m in \u001b[0;36mwrite_array\u001b[0;34m(fp, array, version, allow_pickle, pickle_kwargs)\u001b[0m\n\u001b[1;32m    591\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0mpickle_kwargs\u001b[0m \u001b[0;32mis\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    592\u001b[0m             \u001b[0mpickle_kwargs\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m{\u001b[0m\u001b[0;34m}\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 593\u001b[0;31m         \u001b[0mpickle\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mfp\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mprotocol\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m**\u001b[0m\u001b[0mpickle_kwargs\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    594\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflags\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mf_contiguous\u001b[0m \u001b[0;32mand\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0marray\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mflags\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mc_contiguous\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    595\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0misfileobj\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfp\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mOSError\u001b[0m: [Errno 22] Invalid argument"
     ]
    }
   ],
   "source": [
    "np.save('two_allele_data.npy',np.array([results,params_out]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 443,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([list([array([[[  0, 100,   0],\n",
       "        [  3,  97,   0],\n",
       "        [  4,  96,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,  99,   0],\n",
       "        [  2,  98,   0],\n",
       "        [  2,  98,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,  99,   0],\n",
       "        [  2,  98,   0],\n",
       "        [  2,  98,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       ...,\n",
       "\n",
       "       [[  1,   9,  90],\n",
       "        [  4,   2,  94],\n",
       "        [  8,   1,  91],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,   9,  90],\n",
       "        [  4,   2,  94],\n",
       "        [  8,   1,  91],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  4,   2,  94],\n",
       "        [  8,   1,  91],\n",
       "        [ 11,   1,  88],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]]]), array([[[  0, 100,   0],\n",
       "        [  3,  97,   0],\n",
       "        [  4,  96,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,  99,   0],\n",
       "        [  8,  92,   0],\n",
       "        [  5,  95,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,  99,   0],\n",
       "        [  8,  92,   0],\n",
       "        [  5,  95,   0],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       ...,\n",
       "\n",
       "       [[  1,   7,  92],\n",
       "        [  1,  15,  84],\n",
       "        [  1,   7,  92],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  1,   7,  92],\n",
       "        [  1,  15,  84],\n",
       "        [  1,   7,  92],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]],\n",
       "\n",
       "       [[  5,   1,  94],\n",
       "        [  3,   1,  96],\n",
       "        [  8,   0,  92],\n",
       "        ...,\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]]])]),\n",
       "       list(['reps=1', 'K=[100 500]', 'mu=[0.0005 0.001  0.005 ]', 'alphas=[3 5]'])],\n",
       "      dtype=object)"
      ]
     },
     "execution_count": 443,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.array([results,params_out])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 417,
   "metadata": {},
   "outputs": [],
   "source": [
    "fix_times = []\n",
    "for i in range(len(L_hist[0])):\n",
    "    fix_times.append(np.where(L_hist[:,i,1] <thresh)[0][0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 435,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x15cb54e0b8>]"
      ]
     },
     "execution_count": 435,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(np.array(fix_times)/K)\n",
    "plt.plot(100*(40-np.arange(40)) / (2*(r*alpha)**.5 - 2*(r)**.5))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 429,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n",
       "       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,\n",
       "       34, 35, 36, 37, 38, 39])"
      ]
     },
     "execution_count": 429,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.arange(40)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-54-ea47c38357ac>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m      4\u001b[0m     \u001b[0madd\u001b[0m\u001b[0;34m=\u001b[0m \u001b[0;34m[\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m     \u001b[0;32mfor\u001b[0m \u001b[0mi\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmax\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mlengths\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m-\u001b[0m \u001b[0mlen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m         \u001b[0madd\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mK\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mzeros\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mn_allele\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      7\u001b[0m     \u001b[0mhist_pad\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mu\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0masarray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0madd\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0maxis\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "lengths = [len(u) for u in L_history]\n",
    "hist_pad =  \n",
    "for u in L_history:\n",
    "    add= [] \n",
    "    for i in range((max(lengths) - len(u))):\n",
    "        add.append(np.append([K],np.zeros(n_allele)))\n",
    "    hist_pad.append(np.append(u,np.asarray(add),axis=0))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x151e0a04e0>]"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "iVBORw0KGgoAAAANSUhEUgAAAXAAAAD4CAYAAAD1jb0+AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAADh0RVh0U29mdHdhcmUAbWF0cGxvdGxpYiB2ZXJzaW9uMy4xLjIsIGh0dHA6Ly9tYXRwbG90bGliLm9yZy8li6FKAAAgAElEQVR4nO3deZxcZZ3v8c+vesu+dNIJDVkhLBOCEAmbcUEGBFFHmDtzBb2ICzIuc9UrOoI613XuSxhnEHWuiDCKknEERXFAmWGTAZEwCRAIWcgeEkLS2chGd7rqPPNHnequ7tTWVXXqLP19v179StU5Vad+OV317aee85znmHMOERGJn1TYBYiISHUU4CIiMaUAFxGJKQW4iEhMKcBFRGKquZEvNnnyZDdr1qxGvqSISOwtXbp0p3OuY/Dyhgb4rFmzWLJkSSNfUkQk9sxsU6Hl6kIREYkpBbiISEwpwEVEYkoBLiISUwpwEZGYUoCLiMSUAlxEJKYaOg5cRMrr7s3woz9s5LXDaaaOH8H7zppZl+0+vmYnT23YxVtO7OD0me112aaESwEuEjH/tXE319+/qu/+hScfxeQxbTVv9xv3rWDVK/t5evNe7rjqrJq3J+FTF4pIxPRmPAAuP3PGgPv12m7aq8/2JHwKcJGISWeyV8lqa04NuF+rjKerbyWNAlwkYnJB2+oHeL2CN+1vR1dRTA4FuEjEZPyEbW1KDbhfK08t8MRRgItETK7F3RZUC7wuW5MoUICLRExQXSheriWvBE8MDSOUxHp8zU7ue35b2GUM2fquA0B/gN/04Bomjm6tebv7utM1b0OiRQEuiXXr4+t5fM3OuoRfo83tHMfZx05i5qRRLN28py7bnDCyhR37e3BqgieGAlwSK51xvG7aeO7++MKwS6nao597a123d/ktT2oceIKoD1wSK+M5mlN6i+cz0zDCJNG7WxIr4zmaUhZ2GZFipmOYSaIAl8RKe54CXBKt4gA3syYze8bM7vXvzzazxWa21sx+bmbxO1IkiZZxKMAHMQynPpTEGEoL/FPAyrz71wM3OufmAHuAD9ezMJFaZTyPZgW4JFhFAW5m04B3ALf69w04D/iF/5DbgUuCKFCkGncteYnlW/eRUoAPoD7wZKm0Bf5t4G+A3PijScBe51zuzIAtwDGFnmhmV5vZEjNb0tXVVVOxIpVatHgzAOf/yZSQK4ke9aAkR9kAN7N3Ajucc0ureQHn3C3OuQXOuQUdHR3VbEJkyDKe47yTpvCeM2aEXYpIYCo5kWch8GdmdjEwAhgH3ARMMLNmvxU+DdgaXJkiQ5P2HClT98lgZqYulAQp2wJ3zl3nnJvmnJsFXAY87Jx7H/AI8Bf+w64E7gmsSpEh8jynA5iSeLWMA/888BkzW0u2T/y2+pQkUru059HUpAAfzECd4AkypLlQnHO/B37v314PnFn/kkRq5zloUhdKQYrv5NCZmJJIaY0BL0h/05JFsxFKojyyegc3PbiGV17t1hjwAgz1oCSJWuCSKI+u7mL51ldZOGcy73xdZ9jliARKLXBJlIznGDuimR9/UIdnCskOI1QTPCnUApdESXuOJs0BXpK6UJJD73RJlIzn0aR3dVE6KpAseqtLomQ8dBWeEnRFnmTRO10SJaOLOMgwogCXRNFFHMrRXChJolEoEhnfe3gNP3vqpZq2setgD9MmjqpTRcmkK/IkhwJcIuOJdbvoSWc498Ta5vBeOGdSnSpKHp2JmSwKcImMtOeYM2UM3/rLU8MuJbGU38miPnCJDM9z6r8WGQIFuESGTsIJnoYRJos+LRIZGc+hKbyDp1Ppk0MBLpGRUQs8cKZe8ETRp0UiI6PLoAVOXSjJogCX0P30yU2c8KXfsXr7fprVhxKqH/7net5365NhlyEV0jBCCd3KbftoMuNj5x7HxfM0h3eQzEpfUu3vfruyYbVI7RTgErpMxjF+ZAufv+iksEsZFnQmZnKoC0VCl9b474bRQcxkUYBL6DynAG+YMl0oEi8KcAldWqNPRKqiAJfQZTxPV5BvEAM1wRNEBzElVM45dh88TJOmyWuYtOd49VBv2GVIHSjAJVTX3f08T67fzanTxoddyrDQ2pRi8+5DnPq1/wi7FKkDBbiEavPuQwB87d3zQq5kePjknx7PvGOK/7H82r0rGliN1EoBLqHKeI6zZrdz6vQJYZcyLMyaPJoPvXF20fUbdx3kN8tebmBFUgsdxJRQZTyn0+cjRL+JeFGAS6jSniOlA5iRohM146NsgJvZCDN7ysyWmdkLZvZVf/mPzWyDmT3r/5wWfLmSNJ7TGPAoMf0xjZVK+sB7gPOccwfMrAV43Mx+56/7nHPuF8GVJ0mXzmgO8KjRXCnxUfaT47IO+Hdb/B/9hqVm3b0ZNu46SJPyO1L04Y6Pij46ZtZkZs8CO4AHnHOL/VV/Z2bPmdmNZtYWWJWSSH/9L09z6HCG0a0aDBUV6kGJl4oC3DmXcc6dBkwDzjSzecB1wEnAGUA78PlCzzWzq81siZkt6erqqlPZkgRdBw4D8Pm3axrZSFETPDaG9OXVObcXeAS4yDm3ze9e6QF+BJxZ5Dm3OOcWOOcWdHR01F6xJIbnOd56YgdTx40IuxTxabrZeKlkFEqHmU3wb48ELgBWmVmnv8yAS4DlQRYqyaOLGEdPuSv2SLRU0vnYCdxuZk1kA/9O59y9ZvawmXWQHfv/LPDRAOuUBNJFjKNJo1Dio2yAO+eeA+YXWH5eIBXJsJH2PF3IIWL024gXfX+V0HgOBXgEqf0dHwpwCcWWPYfYsPOgulAiRsMI40UBLqF4zw+eBGDcyJaQK5F8Zqa5UGJEAS6h2HPoMHM7x/G5C08MuxQZxKkTJTYU4BKaNxw3idFtOgszStSDEi8KcAlF2nM0aR7w6DFNJxsnCnAJhec5XchYpEYKcAlFWifxRJJh6gGPEQW4NJznZSMipQCPJiV4bOgIUkzsPNDDE+t21bSNo8aN4MzZ7XWqqDq9GY+HVm4HUAs8gtSrFS8K8Ji46cE1/PTJTTVtI2Xw3FcuZEyIIz8eXd3FR+94GoBJYzSFfNQYGkYYJwrwmDh4OM3UcW0suursqp7/m2e38p2H19LTmwk1wA8eTgPwkw+dyZuOnxxaHSJJoACPCc9ztDU3MWfKmKqeP8WfczsT8hgxz3/96e2jdAHdCDINI4wVHcSMiVpHbeSem/HC/XSmM9nXV/93dCm/40MBHhOeczWN2sg9NxegYcloBEqk6Yo88aIAj4l0pj4tcC/k78e5Lhy1wKMp24WiNnhcKMBjwnOuprmzc89Nh9yFkmuBax5wkdrpIGYM7D10mAdX7uB108ZXvY1cYN61ZAsdY8sP3xvb1sz/OH1a3YL2xe37eWzNTp7akB3LrtPooyk7jFDiQgEeA796ZisAUyoI3mKOnjCSlMHNj66r+DknHDWW06ZPqPo1891w/2oe9E/gaR/dyqi2prpsV+pPPSjxoQCPgZ60B8BNlx1xadKKvX7GRJZ/9UJ6KziI+dSG3XzkJ0vo6c1U/XqD9aQzvG7aeH764bMY0ZKirVkBHkn6ZhQrCvAYyPUbN9c4/eqo1sp+3eNGNA943XrIeI625hTjdQWeSFN8x4sOYsZAX4CnGvPryvV71/Okn4znSKl1J1JXCvAYyI0cadTAjSBGrGQ8V/M3CAle7m+shhLGgwI8BjKeR1PKGnbqeV8LvI4n/aTVAo+F3Ik8yu94UIDHQMZr7LjpILpQPKcLOIjUmw5iRtiuAz3c/sRG/rh+V0PDL9fX/sulW3hm8966bPPlva8xZeyIumxLgpP7knT9/asGfONrH93CVW88tugUCNv3dXPHk5v6RjmNbm3iI28+lhEtGm0UJAV4hD2wYjvfeXgtrU0pTptRn/HYlZg6ro2p49r4/Ytd/P7Frrptd+7R4+q2LQnG8VPGMLKliR89sbFvmec50p7jgrlHMXvy6ILPu++5bXzXf686HL0Zx+mzJvKG4zRlcJAU4BHWm8mO//7DtedVdPZkvUwY1criL5zfsNeT6Hj7KZ28/ZTOAct+s+xlPvmzZ8h4XtHn5d6rz375Al54eR9/efMfKfFwqRP1gUdY2tPETxK+3Nuv1KCkdIE5bnRln+ApwCNMU69KFORGD5U6pt03SZlpQtpGUoBHWEYtcImA/hZ48QTPn2Wyfyx50JVJ2QA3sxFm9pSZLTOzF8zsq/7y2Wa22MzWmtnPzaw1+HKHl0JfS0UaLTcapVyADz5XQfkdvEpa4D3Aec65U4HTgIvM7GzgeuBG59wcYA/w4eDKHJ40d7ZEQe7dV6pFnfZc3hTBer82StlRKC57Tu0B/26L/+OA84D3+stvB74CfL/+JSbLrY+tZ+W2/RU9dsW2fYDmzpZwpcq0wLv293Dzo+to8adK0On4jVPRMEIzawKWAnOAfwLWAXudc2n/IVuAY4o892rgaoAZM2bUWm/sXX//KkY0NzGuwln5zj2xQwcxJVS5OdSK5fET63YCMPfo7AVH+lrsAdclFQa4cy4DnGZmE4BfASdV+gLOuVuAWwAWLFgw7H+nac/xwYWz+MzbTgy7FJGKlOsDz10o+zuXnTZwxbD/tAdvSKNQnHN7gUeAc4AJZpb7AzAN2Frn2hLH8xzOaVigxEvu3VpsHHhuzpzcsZpGTbomlY1C6fBb3pjZSOACYCXZIP8L/2FXAvcEVWRS6IrsEkf948ALJ/jg+er7u1DUBA9aJV0oncDtfj94CrjTOXevma0A/tXMvgE8A9wWYJ2JoBNzJI76D2IWXt83X/2g5qCOYQavklEozwFHXIzRObceODOIopJKJ+ZIHKXKjCrxBrfA9fZuGJ2J2UD9J+Zot0t8WIUt8L4+cF0UomGGxWyEzjm+9OvlbNnzWqh1pP3p2XRlMYmTXIv6m79byYRRR55w/dKeQ0D+QczscuV38IZFgO/rTrNo8WaOmTCSyQ2clrWQBTMncsbs9lBrEBmKE6aO5Y1zJrO/J83e13qPWD92RAvvOvVoRg26eINO5AnesAjwXN/zR940mw8snB1yNSLx0j66lTuuOivsMqSAYdEZ29d10TQs/rsioVIXSuMMi0TLXRlEc4qIBE8HMRtnWAR4rgWu4XsijaQED9qwCHCdQCPSOPqi2zjDKsDVAhcJnq7I0ziJHoWydNNuvvpvKzjYk531Vi1wkcZRfgcv0S3wxRt289yWV5k5aTTvfF0nZ87S+GuRoOmyxo2T6BZ4bo6Gm//X6bQ2J/pvlUhkqAulcRKdamn1fYs0nKaTbZxEB3jGc5ip71skDGqBBy/xAa6Td0QaSx+5xkl+gKv1LdJg/pmYIVcxHCQ6wNMKcJHQaDbC4MVuFMqhw2n+/P8/wa6Dh8s+9kB3mmZNvi3SUOpCaZzYBfiOfT2semU/Zx/bzuzJY8o+/pRjxjegKhHJUX43TuwC3PO/ll12xgwumX9MyNWIyGBmmo2wUWLXB567Lp++polEm8aBBy92AZ47tp1SgotEkj6ZjRO7AM+1wBXgItGkU+kbJ4YBnmuBh1yIiBSkK/I0TvwC3L88mhrgIjLcxS/A/T/rpgQXiaQm/9yLa+5axqxr72PWtffxw/9cH3JVyRS7YYROfeAikXb0+BF87d0ns/NA9mS72x5bz9odB0KuKpliF+DqAxeJNjPj/efM6rt/53+9FF4xCRe7LpTccRG1wEXiQ2PCgxG7AO/vAw+5EBGpiD6rwYldgDunE3lE4kZDCoNRNsDNbLqZPWJmK8zsBTP7lL/8K2a21cye9X8uDr5cnUovIpJTyUHMNHCNc+5pMxsLLDWzB/x1NzrnvhVceQM559jjTyOrFrhIPET5k7rrQE9fo7CYliZjwqjWxhQ0RGUD3Dm3Ddjm395vZiuBUKYB/MZ9K7nt8Q0Ausq8SIxEsQflx3/YwFf+bUVFj731/Qs4f+7UgCsauiENIzSzWcB8YDGwEPhrM3s/sIRsK31PgedcDVwNMGPGjJqK3brnNaaMbeO6i09i/vQJNW1LRBojqifdbd37Gq1NKf72XXOLPmZ/dy833L+aV/Z1N7CyylUc4GY2Bvgl8Gnn3D4z+z7wdbJ/XL8O/APwocHPc87dAtwCsGDBgpr+EGeco310K5fOn1bLZkSkwaJ4EDPjQVtziivOnln0MTv2dXPD/asj+Q0CKhyFYmYtZMN7kXPubgDn3HbnXMY55wE/BM4MrsysjOd0iTQRqYuM5/Wd9l+MRXxqxUpGoRhwG7DSOfePecs78x52KbC8/uUNlL3KvPq+RaR2ac/RXOaU7r78bkA91aikC2UhcAXwvJk96y/7AnC5mZ1G9v+2EfirQCrMk/EcaoCLxE8Uz8T0nCs7mi231is3VCUklYxCeZzCI4F+W/9ySst4jma1wEViJaLHMElnKmmB+3ObN6KgKsQmDT3PsWbHAZTfIjEUsQR85dVudh88TKpMgKei3QUenwBf9NRmdh7oYWRLU9iliEiMHexJ8+YbHuGhVTsY01a6E6Lv6kKNKKwKsZlONncG5jcuPSXkSkRkKMyiFYAHe9Iczni896wZXPXG2aUf3NcCj9L/oF9sWuBp/yDC0eNHhFyJiMRZLktOnTaeYzvGlHxsVPvvc2IT4J7naEpZZM/qEpHCLGKzoWS8ymc07RuFohZ4bdJ+gItI/ESpCyIX4JWcFJgL+QiVP0BsAjzjeTSp9S0SO1H72KaH0gKP+Ik8MQpwyo7ZFJFoilIA5rpDKjmnpG8USpT+A3liMQpl7Y79/P7FHWGXISIB6O7NsHTTnr6ujcEmj2lj7tHjhrzdVw/1smzL3iOWb959CKCiLtn+Frjj5b2vsXbHgYKPO3X6BMaPbBlyjbWKRYDf/sQm1ncdZOakUWGXIiJDVC4mf/LHjfy/364quj5lsOzLb2PsiKEF5DfuW8FdS7cUXT+UwHUOPrboaZa9dOQfBIArzp7J1y+ZN6T66iEWAf6RNx3LJfOPZtpEBbhIHJXqgtjfncYMfvHRc45Yd//yV/jhYxvo7vUYO8QRxPu708xoH8WN7zn1iHUjWpqY21m+Vd9/ENOxv7uXhXMm8ZkLThjwmI/d8TQHD6eHVlydxCLAZ0waxQy1vkViqdzQ37TnaEmlOH1m+xHrVm7bD1Q3GVbac4xpay643Urlzyab8RwdY9qO2N7I1qbQ+shjcxBTROKrVL55JYYI1zIdd8bzar5+QO7ZjuzkV4WmszbCGyeuABeRUJU6x6OWUSAZV/vFzy1vHLjnHE0FEjNlVvbCyEFRgItIoMpFaKaSFngVXSgZz6t56HEq7/XTRS4oY6YWuIgkWKkzMUsFeC3TuaYzrux0seXkWuCey9V55GNSZqGdaRqLg5giEmMlMrS7N8NPn9zEhFGFh/TVMp3ruq6DnDC19GRVlVq5bR/dvZmCJ/9knOO3z7/CLwcNWTxzdjvT24MdfKEAF5HAFQvgRYs3A7D3UG/hB/jhX80lzXYe6GHS6NYhP2+wjrFtPLBie9/twdZ3HQTgmruWDVh+0clHcfMVp9f8+qUowEUkNBt2Fj6zMafWyTPOPbGjxi3Aw9e8hT0HezGDaRNHFn3cbVcu4PgpYwH4qzuWcqg3U/Nrl6MAF5FA1RLCVuVsgLk+6bY6XMFr7IiWis4CPWbiyL7zVUa2pBpyIWQdxBSR4FWZZakqR6HksrORE+Dlv1ZzKkXa8wJ/TQW4iASqlouw5J461MZsLjwbeQ2B/CGGTSkrOjlXPSnARSRw1YzjhvwTeYbYAvcbvw0N8Lw/VApwEUmEUhFa7nJr1V5QIdcCb2QXSlNT4wNcBzFFJDT3PLu15PpKD2IuXr+LZ17ay8iWJqaOa2PquOzUhbWeSj8Ug1vgr+zr5uZH1/Utu3heZ90n5VOAi0jgCgXwjv3d7OvOTsP6gTfMKvi8/kgsneB/e89yXtzePyRxent2uN+MgE+kAXjHKZ08tGr7gPnFZ08ezcOrdvDN3/XPc37SUWMV4CISL8UawYfT2W6Or18yjyvOnlnyueV6I3rSHm3NKXr8be492MvR40dw/typVdU8FN9773wynqM57zz7L73jT/js204c8LjW5vr3WCvARSRwhVrguT7iUSXGalc6G2E64wYEeMa5QAKzEDM7YtpaM2Nka+1j0MvRQUwRCVSxA5W5AC81Z3elsxF6ztHa3DTgfiP7v8OiABeRwBUK4FyAlwraSmcjTHvZFniO5xXvukmSsgFuZtPN7BEzW2FmL5jZp/zl7Wb2gJmt8f+dGHy5IpIUGT+VSw/1y03nWjrBM97ALpO056kF7ksD1zjn5gJnA58ws7nAtcBDzrnjgYf8+yIiAxTL0XTGb4GXCPBKL6mW8RyteQcRvTpcjScOyga4c26bc+5p//Z+YCVwDPBu4Hb/YbcDlwRVpIjEW6EA/vUz2THgpVrguTV/WLuz4PqM5/juQ2s4dDhNW8vAOBsG+T20PnAzmwXMBxYDU51z2/xVrwAFx+uY2dVmtsTMlnR1ddVQqogkyV3+BRBmThpd9DGzJ2fX/Yc/H/dg67sO8A8PvEhzKsWFJx81YF0tc7DERcUBbmZjgF8Cn3bO7ctf57ITFRT8kuOcu8U5t8A5t6Cjo/a5eUUkfgqFQ8rg/efMZM6U4lfNOX7qWN5w3CSKNdJ7/W6YG99zGp946xw2fvMdHNV3FmatVUdfRQFuZi1kw3uRc+5uf/F2M+v013cCO4IpUUSSKO1VNtSv1FXf+4Yipgaexp57XtJVMgrFgNuAlc65f8xb9RvgSv/2lcA99S9PROKuWFdGxnMVTTZV6qrvfdPGNhUK8KFWGj+VnIm5ELgCeN7MnvWXfQH4JnCnmX0Y2AT8z2BKFJG4K3YmZiXTvZpZ0VEouWDPn0gq90dhOPSBlw1w59zjFJ8R8k/rW46IJE2x8Kg0wFNWfD7w3FDEwl0oQ6szjnQmpog0wJEBnK6wC6WSPvBUgQBXC1xEpEZm8OT63XzyZ8/0LcvlcamTeHJSBfrAN+w8yHcfXsO2vd3AwBZ47uBl8uNbAS4iDXCgJ81vn9/G9Lz5uY/rGM2Cme1ln1uoD/yhldu5++mtzJw0ilOOGc+syf1jyc87aQoHetK85YTkD1tWgItIQ0xvH8Ujnz13yM8zjmyBp/2uk/s/9eYjpm397IUn8tkLB87FnVTqAxeRQOW6oqs9qJgq0ALv7/uuobAEGOb/fRFplOYq0zaVOrIF3n8Cz/COsOH9vxeRwOUu6FDJkMGCzzcr2oUyHIYKlqIAF5GGqDbAU2ZHDEL0/DHkw2GoYCkKcBFpiOoD/MgzOdMVngSUdBqFIiKByl1OreouFODlva9x+S1P9i3btOvggNPnhysFuIgEau+hXoAB16wciovmHcXLe7v7DlwCTJs4iovmja9LfXGmABeRQHl+8F58SmdVz79oXicXzavuuUmnPnARCVRuxIj6rOtPAS4igeqb8lUBXncKcBEJVKGr5kh9KMBFJFDqQgmOAlxEAuUpwAOjABeRQLX4wwc1brv+NIxQRAL15XfN5bE1Ozljdvm5v2VoFOAiEqhL50/j0vnTwi4jkdSFIiISUwpwEZGYUoCLiMSUAlxEJKYU4CIiMaUAFxGJKQW4iEhMKcBFRGLK3OCLzQX5YmZdwKYqnz4Z2FnHcuohijVBNOtSTZWLYl2qqXJB1DXTOdcxeGFDA7wWZrbEObcg7DryRbEmiGZdqqlyUaxLNVWukXWpC0VEJKYU4CIiMRWnAL8l7AIKiGJNEM26VFPloliXaqpcw+qKTR+4iIgMFKcWuIiI5FGAi4jElXMu8j/ARcBqYC1wbQDbnw48AqwAXgA+5S9vBx4A1vj/TvSXG/Adv57ngNfnbetK//FrgCvzlp8OPO8/5zv43VcV1NYEPAPc69+fDSz2t/NzoNVf3ubfX+uvn5W3jev85auBC2vZr8AE4BfAKmAlcE7Y+wn4P/7vbTnwM2BEGPsJ+GdgB7A8b1ng+6bYa5So6e/9399zwK+ACdXug2r2c7G68tZdAzhgctj7yl/+v/399QJwQ6P3Vcn3fq3hF/QP2QBbBxwLtALLgLl1fo3O3JsCGAu8CMwFbsj9AoBrgev92xcDv/PfWGcDi/PeHOv9fyf6t3Mf2Kf8x5r/3LdXWNtngH+hP8DvBC7zb98MfMy//XHgZv/2ZcDP/dtz/X3W5r+B1vn7tKr9CtwOXOXfbiUb6KHtJ+AYYAMwMm//fCCM/QS8GXg9A8My8H1T7DVK1PQ2oNm/fX1eTUPeB0Pdz6Xq8pdPB/6d7Al/kyOwr94KPAi0+fenNHpflXz/1zMIg/gh28L797z71wHXBfya9wAXkP0r2ukv6wRW+7d/AFye9/jV/vrLgR/kLf+Bv6wTWJW3fMDjStQxDXgIOA+4138z7qT/w9e3b/w3/Tn+7Wb/cTZ4f+UeV81+BcaTDUsbtDy0/UQ2wF8i+yFu9vfThWHtJ2AWAwMg8H1T7DWK1TRo3aXAokL/t3L7oJr3Y7m6yH67OxXYSH+Ah7avyIbu+QX2W0P3VbGfOPSB5z6gOVv8ZYEws1nAfLJfZaY657b5q14BppapqdTyLQWWl/Nt4G8Az78/CdjrnEsX2E7fa/vrX/UfP9RaS5kNdAE/MrNnzOxWMxtNiPvJObcV+BawGdhG9v+9lHD3U75G7Jtir1GJD5FtoVZTUzXvx6LM7N3AVufcskGrwtxXJwBvMrPFZvaomZ1RZU113Vc5cQjwhjGzMcAvgU875/blr3PZP4+ugbW8E9jhnFvaqNesQDPZr5jfd87NBw6S/RraJ4T9NBF4N9k/LkcDo8n2QUZOI/bNUF7DzL4IpIFFQdZUYS2jgC8A/7dRr1nhvmom++3ubOBzwJ1mZkHXVqk4BPhWsv1iOdP8ZXVlZi1kw3uRc+5uf/F2M+v013eSPcBRqqZSy6cVWF7KQuDPzGwj8K9ku1FuAiaYWXOB7fS9tr9+PLCrilpL2QJscc4t9u//gmygh7mfzgc2OOe6nHO9wN1k912Y+ylfI/ZNsdcoysw+ALwTeJ8fZNXUtIuh7+dijiP7R3iZ/56fBjxtZkdVUVc999UW4G6X9RTZb8OTq6ipnnCiSQUAAAGoSURBVPuqXyX9LGH+kP0LuJ7sLzd3UODkOr+GAT8Bvj1o+d8z8IDHDf7tdzDwoMpT/vJ2sn3EE/2fDUC7v27wQZWLh1DfufQfxLyLgQdCPu7f/gQDD4Tc6d8+mYEHW9aTPdBS1X4FHgNO9G9/xd9Hoe0n4CyyowNG+c+5neyogVD2E0f2oQa+b4q9RomaLiI74qpj0OOGvA+Gup9L1TVo3Ub6+8DD3FcfBb7m3z6BbFeHNXpfFX2/1TMIg/ohexT6RbJHd78YwPbfSPar1HPAs/7PxWT7oR4iO+Towbw3hwH/5NfzPLAgb1sfIjscaC3wwbzlC8gOc1sHfI8KD1L4zz2X/gA/1n9zrvXfELmj4yP8+2v99cfmPf+L/uuuJm9URzX7FTgNWOLvq1/7H5xQ9xPwVbLDvJYDP/U/VA3fT2SHMG4Desm23D7ciH1T7DVK1LSWbBDl3us3V7sPqtnPxeoatH4jA4cRhrWvWoE7/G09DZzX6H1V6ken0ouIxFQc+sBFRKQABbiISEwpwEVEYkoBLiISUwpwEZGYUoCLiMSUAlxEJKb+G9IhwAiyPSARAAAAAElFTkSuQmCC\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot([len(u) for u in L_history])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x151d440518>]"
      ]
     },
     "execution_count": 39,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot([len(u) for u in out1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 545,
   "metadata": {},
   "outputs": [],
   "source": [
    "out2 = run_stepping_stone(n_gen = 3000,K = 100,n_allele = 1,r = .1,alpha = 5,mu = .001)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 546,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x17b6f89c88>,\n",
       " <matplotlib.lines.Line2D at 0x17b7097550>]"
      ]
     },
     "execution_count": 546,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "stand = odeint(standing_wave,[1,-(2*2**.5)/100],np.arange(70),args=(2*2**.5,1))[:,0]\n",
    "w_0 = (500*stand).astype(int)\n",
    "w_0 = w_0[w_0>1]\n",
    "plt.plot(w_0)\n",
    "plt.plot(out2[-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 541,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.005656"
      ]
     },
     "execution_count": 541,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "(2* 1.414)/500"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [],
   "source": [
    "K=500\n",
    "n_allele=1\n",
    "\n",
    "L_empty= np.append([K],np.zeros(n_allele,dtype=int))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 155,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[126, 374],\n",
       "       [191, 309],\n",
       "       [228, 272],\n",
       "       [276, 224],\n",
       "       [290, 210],\n",
       "       [315, 185],\n",
       "       [337, 163],\n",
       "       [360, 140],\n",
       "       [375, 125],\n",
       "       [388, 112],\n",
       "       [402,  98],\n",
       "       [420,  80],\n",
       "       [438,  62],\n",
       "       [444,  56],\n",
       "       [447,  53],\n",
       "       [464,  36],\n",
       "       [467,  33],\n",
       "       [474,  26],\n",
       "       [481,  19],\n",
       "       [483,  17],\n",
       "       [487,  13],\n",
       "       [489,  11],\n",
       "       [493,   7],\n",
       "       [495,   5],\n",
       "       [497,   3],\n",
       "       [495,   5],\n",
       "       [497,   3],\n",
       "       [498,   2],\n",
       "       [499,   1],\n",
       "       [500,   0]])"
      ]
     },
     "execution_count": 155,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "np.append(out[300],[L_empty],axis=0)\n",
    "          "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 485,
   "metadata": {},
   "outputs": [],
   "source": [
    "stand = odeint(standing_wave,[1,-.1*r**2],np.arange(50),args=(1,r))[:,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 486,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x15cbcfc710>]"
      ]
     },
     "execution_count": 486,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(stand)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 482,
   "metadata": {},
   "outputs": [],
   "source": [
    "n_gen=1000\n",
    "K=100\n",
    "n_allele=3\n",
    "r=.1\n",
    "alpha=2\n",
    "mu=.001\n",
    "L_h = run_stepping_stone(n_gen,K,n_allele,r,alpha,mu)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 483,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x15cc0afcc0>,\n",
       " <matplotlib.lines.Line2D at 0x15cc0afe10>,\n",
       " <matplotlib.lines.Line2D at 0x15cc0aff60>,\n",
       " <matplotlib.lines.Line2D at 0x15cc0bc0f0>]"
      ]
     },
     "execution_count": 483,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(L_h[-1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fix_time_2allele(K,r,alpha,mu,thresh):\n",
    "    func_args = [K,n_allele,r,alpha,mu]\n",
    "    ##initialize probability matrix\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,1:] = 1-r*(alpha**np.arange(n_allele))\n",
    "    \n",
    "    stand = odeint(standing_wave,[1,-r**.5],np.arange(70),args=(1,r))[:,0]\n",
    "    w_0 = (K*stand).astype(int)\n",
    "    w_0 = w_0[w_0>1]\n",
    "    \n",
    "    ##initialize array\n",
    "    L_empty= np.append([K],np.zeros(n_allele,dtype=int))\n",
    "    L0 = np.zeros((len(w_0),n_allele+1),dtype=int)\n",
    "    L0[:,1] = w_0\n",
    "    L0[:,0] = K-w_0\n",
    "    L= np.append(L0,[L_empty],axis=0)\n",
    " \n",
    "\n",
    "    #begin evolution\n",
    "    fixed=False\n",
    "    fixed_hist=[]\n",
    "    est_hist=[]\n",
    "    t = 0\n",
    "    while not fixed:\n",
    "        L = update(L,L_empty,P,*func_args)\n",
    "        fix_bools = L[:,1]< int(thresh*K)\n",
    "        est_bools = L[:,2]> int(1/(r*alpha))\n",
    "        fixed= all(fix_bools)\n",
    "        if any(fix_bools):\n",
    "            fixed_hist.append(fix_bools)\n",
    "            \n",
    "        if any(est_bools):\n",
    "            est_hist.append(est_bools)\n",
    "        t+=1\n",
    "\n",
    "    return fixed_hist,est_hist,L"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "metadata": {},
   "outputs": [
    {
     "ename": "FileNotFoundError",
     "evalue": "[Errno 2] No such file or directory: 'start/two_allele_data_2019-12-08 20:03:00.412718.npy'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mFileNotFoundError\u001b[0m                         Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-35-5dd95285160a>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     19\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     20\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 21\u001b[0;31m     \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'start/two_allele_data_%s.npy'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mresults\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mparams_out\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     22\u001b[0m \u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0msave\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'start/two_allele_data_%s.npy'\u001b[0m \u001b[0;34m%\u001b[0m \u001b[0mstart\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mresults\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mparams_out\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/anaconda3/lib/python3.7/site-packages/numpy/lib/npyio.py\u001b[0m in \u001b[0;36msave\u001b[0;34m(file, arr, allow_pickle, fix_imports)\u001b[0m\n\u001b[1;32m    500\u001b[0m         \u001b[0;32mif\u001b[0m \u001b[0;32mnot\u001b[0m \u001b[0mfile\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mendswith\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m'.npy'\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    501\u001b[0m             \u001b[0mfile\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfile\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m'.npy'\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m--> 502\u001b[0;31m         \u001b[0mfid\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mopen\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;34m\"wb\"\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m    503\u001b[0m         \u001b[0mown_fid\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m    504\u001b[0m     \u001b[0;32melif\u001b[0m \u001b[0mis_pathlib_path\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mFileNotFoundError\u001b[0m: [Errno 2] No such file or directory: 'start/two_allele_data_2019-12-08 20:03:00.412718.npy'"
     ]
    }
   ],
   "source": [
    "import datetime\n",
    "from stepping_stone_funcs import*\n",
    "start = datetime.datetime.now()\n",
    "K_space = np.array([500,1000])\n",
    "mu_space = np.array([.001,.005])\n",
    "alphas = np.array([2,5])\n",
    "\n",
    "params_out = ['K='+str(K_space),'mu='+str(mu_space),'alphas='+str(alphas) ],\n",
    "\n",
    "r=.1\n",
    "\n",
    "results = []\n",
    "product(K_space,mu_space, alphas)\n",
    "for K,mu,a in product(K_space,mu_space, alphas):\n",
    "    fix,exp,L = fix_time_2allele(K,r,a,mu,3/K)\n",
    "    results.append([fix,exp,L])\n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    np.save('$s/two_allele_data_%s.npy' % start,np.array([results,params_out]))\n",
    "np.save('/start/two_allele_data_%s.npy' % start,np.array([results,params_out]))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "metadata": {},
   "outputs": [],
   "source": [
    "np.save('wo_allele_data_%s.npy' % start,np.array([results,params_out]))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1221,
   "metadata": {},
   "outputs": [],
   "source": [
    "K=1000\n",
    "n_allele=2\n",
    "r=.1\n",
    "alpha=5\n",
    "mu=.001\n",
    "\n",
    "fix,est,L = fix_time_2allele(K,r,alpha,mu,thresh=.001)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 573,
   "metadata": {},
   "outputs": [],
   "source": [
    "def fix_time(K,n_allele,r,alpha,mu,thresh, track):\n",
    "    func_args = [K,n_allele,r,alpha,mu]\n",
    "    ##initialize probability matrix\n",
    "    P = np.ones((n_allele+1,n_allele+1))\n",
    "    P[0,1:] = 1-r*(alpha**np.arange(n_allele))\n",
    "    \n",
    "    L,L_empty = initialize(*func_args)\n",
    "    L_history=[L]\n",
    "    #begin evolution\n",
    "    fixed=False\n",
    "    t = 0\n",
    "    if track:\n",
    "        fix_times = np.zeros(len(L))\n",
    "        est_times = np.zeros(len(L))\n",
    "        fb_1, eb_1 = (np.zeros(len(L)) == 1),(np.zeros(len(L)) == 1) \n",
    "    while not fixed:\n",
    "        L = update(L,L_empty,P,*func_args)\n",
    "        L = recenter(L,L_empty,K)\n",
    "        fix_bools = L[:,1] < int(thresh*K)\n",
    "        est_bools = L[:,2] > int(1/(r*alpha))\n",
    "        fixed= all(fix_bools)\n",
    "        if track:\n",
    "            fix_times  = [max(i,time) for i, time in zip((fix_bools^fb_1)*t,fix_times)]\n",
    "            est_times  = [max(i,time) for i, time in zip((est_bools^eb_1)*t,est_times)]\n",
    "            fb_1,eb_1 = fix_bools,est_bools\n",
    "        t+=1\n",
    "    if not track:\n",
    "        return L\n",
    "    else: \n",
    "\n",
    "        fix_times,est_times"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 574,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "0it [00:00, ?it/s]\u001b[A"
     ]
    },
    {
     "ename": "TypeError",
     "evalue": "cannot unpack non-iterable NoneType object",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-574-4c1b690965c1>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[1;32m     12\u001b[0m \u001b[0mproduct\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mK_space\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mmu_space\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0malphas\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     13\u001b[0m \u001b[0;32mfor\u001b[0m \u001b[0mrep\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mmu\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0ma\u001b[0m \u001b[0;32min\u001b[0m \u001b[0mtqdm\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mproduct\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mrange\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mreps\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mK_space\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mmu_space\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0malphas\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 14\u001b[0;31m     \u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0me\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mfix_time\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mr\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0ma\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0mmu\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m3\u001b[0m\u001b[0;34m/\u001b[0m\u001b[0mK\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0;32mTrue\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     15\u001b[0m     \u001b[0mresults\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0mf\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0me\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     16\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mTypeError\u001b[0m: cannot unpack non-iterable NoneType object"
     ]
    }
   ],
   "source": [
    "\n",
    "start = datetime.datetime.now()\n",
    "K_space = np.array([100])\n",
    "mu_space = np.array([.001])\n",
    "alphas = np.array([5])\n",
    "\n",
    "params_out = ['K='+str(K_space),'mu='+str(mu_space),'alphas='+str(alphas) ],\n",
    "\n",
    "r=.1\n",
    "\n",
    "results = []\n",
    "product(K_space,mu_space, alphas)\n",
    "for rep, K,mu,a in tqdm(product(range(reps), K_space,mu_space, alphas)):\n",
    "    f,e = fix_time(K,2,r,a,mu,3/K, True)\n",
    "    results.append([f,e])\n",
    "    \n",
    "    \n",
    "    \n",
    "\n",
    "\n",
    "    \n",
    "    \n",
    "  \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "    \n",
    "            \n",
    "\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[array([108712, 108813, 108133, 101828,  92279,  92238,  85485,  84096,\n",
       "         83175,  82505,  81714,  78785,  76247,  76241,  76160,  75756,\n",
       "         75535,  72066,  69764,  71064,  71738,  71020,  65792,  62630,\n",
       "         63761,  61423,  58831,  60079,      0,      0,      0,      0,\n",
       "             0]),\n",
       " array([ 17029,  16329,  23658,  25264,  31096,  34508,  37436,  37313,\n",
       "         40182,  36506,  39896,  36886,  33707,  31493,  90466,  89726,\n",
       "         91920,  93218,  96217, 108310, 102083, 101828,  85485,  79431,\n",
       "         80943,  76160,  76160,  75756,  72169,  72066,  65792,  65337,\n",
       "         65078]),\n",
       " array([[  6,   2,  92],\n",
       "        [  3,   2,  95],\n",
       "        [  4,   1,  95],\n",
       "        [  6,   0,  94],\n",
       "        [ 10,   0,  90],\n",
       "        [  8,   0,  92],\n",
       "        [ 16,   0,  84],\n",
       "        [ 17,   0,  83],\n",
       "        [ 22,   0,  78],\n",
       "        [ 30,   0,  70],\n",
       "        [ 55,   0,  45],\n",
       "        [ 55,   0,  45],\n",
       "        [ 55,   0,  45],\n",
       "        [ 79,   0,  21],\n",
       "        [ 87,   0,  13],\n",
       "        [ 83,   0,  17],\n",
       "        [ 82,   0,  18],\n",
       "        [ 84,   0,  16],\n",
       "        [ 97,   0,   3],\n",
       "        [ 96,   0,   4],\n",
       "        [ 98,   0,   2],\n",
       "        [ 99,   0,   1],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0],\n",
       "        [100,   0,   0]])]"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "results[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 563,
   "metadata": {},
   "outputs": [],
   "source": [
    " newest_two = max(glob.iglob('t*.npy'), key=os.path.getctime)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 555,
   "metadata": {},
   "outputs": [],
   "source": [
    " newest_mult = max(glob.iglob('m*.npy'), key=os.path.getctime)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 556,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'multi_allele_data_2019-12-15 18:45:27.379389.npy'"
      ]
     },
     "execution_count": 556,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "newest_mult"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 564,
   "metadata": {},
   "outputs": [],
   "source": [
    "data = np.load(newest_two)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 565,
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "cannot reshape array of size 7 into shape (5,2,2,2,2)",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-565-3b2640c8cbb7>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mdata\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mnp\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0marray\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m0\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mreshape\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;36m5\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m2\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mValueError\u001b[0m: cannot reshape array of size 7 into shape (5,2,2,2,2)"
     ]
    }
   ],
   "source": [
    "data=np.array(data[0]).reshape(5,2,2,2,2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 566,
   "metadata": {},
   "outputs": [
    {
     "ename": "IndexError",
     "evalue": "too many indices for array",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mIndexError\u001b[0m                                Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-566-80f6d76089b9>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m()\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0mdata\u001b[0m\u001b[0;34m[\u001b[0m\u001b[0;36m4\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m,\u001b[0m\u001b[0;36m1\u001b[0m\u001b[0;34m]\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;31mIndexError\u001b[0m: too many indices for array"
     ]
    }
   ],
   "source": [
    "data[4,1,1,1,1]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 199,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([597697, 596879, 596481, 598734, 599524, 596864, 595428, 590712,\n",
       "       589717, 583326, 580909, 575037, 573288, 576084, 554873, 555615,\n",
       "       554959, 554873, 537452, 535794, 535779, 532046, 532281, 525545,\n",
       "       417080, 413783, 411134, 407941, 406519, 404372, 404007, 404064,\n",
       "       253432])"
      ]
     },
     "execution_count": 199,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data[4,0,0,0,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 201,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x152177ab70>]"
      ]
     },
     "execution_count": 201,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(data[1,0,0,0,0])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 228,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x1521ea7da0>]"
      ]
     },
     "execution_count": 228,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(np.mean(data[:,1,1,1,0],axis=0)/(500*1000))\n",
    "plt.plot(np.arange(len(np.mean(data[:,1,1,1,0],axis=0)))[::-1]/(2*(5**2-1)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 150,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([254593, 256908, 259315, 260013, 258703, 258266, 248614, 234790,\n",
       "       234103, 233220, 232981, 231929, 229642, 229529, 225482, 219859,\n",
       "       219063, 218708, 213503, 209350, 185452, 181363, 177553, 162926,\n",
       "       161639, 157355, 155997, 155830, 151426, 145486, 140696,      0,\n",
       "            0])"
      ]
     },
     "execution_count": 150,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data[0,0,0,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 168,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x15216a0b38>]"
      ]
     },
     "execution_count": 168,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "hi=data[0,1,0,0]\n",
    "plt.plot(hi[:-5])\n",
    "\n",
    "plt.plot(100000*(np.arange(len(hi[:-5]))[::-1]/(2*(3)**2 -2))+hi[-6])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 44,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[  4,   2,  93,   1,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  1,   2,  90,   7,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  1,   0,  92,   6,   1,   0,   0,   0,   0,   0,   0],\n",
       "       [  5,   0,  87,   8,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  6,   0,  80,  14,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  8,   0,  74,  18,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  7,   0,  74,  19,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [  8,   0,  70,  22,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 11,   0,  77,  12,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 24,   0,  53,  23,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 30,   0,  52,  18,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 40,   0,  44,  16,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 58,   0,  29,  13,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 69,   0,  18,  13,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 71,   0,  22,   7,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 83,   0,  13,   4,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 83,   0,  15,   2,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 78,   0,  21,   1,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 86,   0,  14,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 82,   0,  18,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 94,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 87,   0,  13,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 92,   0,   8,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 84,   0,  16,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 94,   0,   6,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 98,   0,   2,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [ 98,   0,   2,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0],\n",
       "       [100,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0]])"
      ]
     },
     "execution_count": 44,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "data[0,0,0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 85,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[<matplotlib.lines.Line2D at 0x1533a4c048>]"
      ]
     },
     "execution_count": 85,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "plt.plot(lens)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([     0.,      0.,      0.,      0., 121433., 122753., 123115.,\n",
       "       123890., 119972., 129190., 132678., 132678., 132678., 132678.,\n",
       "       132678., 132678., 132678., 132678., 132678., 132678., 132678.,\n",
       "       132678., 132678., 132678., 132678., 132678., 132678., 132678.,\n",
       "       132678., 132678., 132678., 132678., 132678.])"
      ]
     },
     "execution_count": 75,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n",
       "         0,   0,   0, 100, 100, 100, 100])"
      ]
     },
     "execution_count": 78,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pad_data[100]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([False, False, False, False, False, False, False, False, False,\n",
       "       False, False, False, False, False, False, False, False, False,\n",
       "       False, False,  True,  True,  True])"
      ]
     },
     "execution_count": 54,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    " data[0,0,0,0][0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "[False, False, False, False]"
      ]
     },
     "execution_count": 55,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "[False]*4"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "metadata": {},
   "outputs": [],
   "source": [
    "s=.1\n",
    "r=.5\n",
    "m=.1\n",
    "K=1000\n",
    "se = .5*s*m*np.log(2/m) / r\n",
    "p = (np.exp(-2*se)-1)/ (np.exp(-4*se*K)-1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0.058155079116972264"
      ]
     },
     "execution_count": 80,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "p"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
